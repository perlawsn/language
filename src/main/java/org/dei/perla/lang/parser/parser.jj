/* Copyright (C) 2008  Romolo Camplani, Marco Fortunato, Marco Marelli, Guido Rota, Fabio A. Schreiber et al.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
options
{
    JDK_VERSION = "1.8";
    IGNORE_CASE = true;
    STATIC = false;
}

PARSER_BEGIN(Parser)

    package org.dei.perla.lang.parser;

    import java.time.temporal.TemporalUnit;
    import java.time.temporal.ChronoUnit;
    import java.time.Duration;
    import java.util.Collections;
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Set;
    import java.util.TreeSet;

    import org.dei.perla.lang.parser.ast.*;

    import org.dei.perla.lang.query.expression.*;
    import org.dei.perla.lang.query.statement.*;
    import org.dei.perla.lang.persistence.*;

    import org.dei.perla.core.utils.Errors;
    import org.dei.perla.core.descriptor.DataType;
    import org.dei.perla.core.registry.TypeClass;
    import org.dei.perla.core.registry.DataTemplate;

    public final class Parser {

        private static final Object[] EMPTY_DEFAULT = new Object[0];

        private static final String ERROR_STRING = "Error near element %s" +
                "(line %s, column %s): ";

        private static void addError(String msg, Token t, Errors err) {
            err.addError(ERROR_STRING + msg, t.image, t.beginLine,
                    t.beginColumn);
        }

        private static Errors inContext(Errors err, Token t) {
            return err.inContext(ERROR_STRING, t.image, t.beginLine,
                    t.beginColumn);
        }

    }

PARSER_END(Parser)

/*
 * SEPARATORS
 */
SKIP :
{
    " "
    |
    "\r"
    |
    "\t"
    |
    "\n"
}

/*
 *	COMMENTS
 */
MORE:
{
    "/*" : COMMENT
}

<COMMENT> MORE:
{
    <~[]>
}

<COMMENT> SKIP:
{
    "*/" : DEFAULT
}

/*
 * CREATE CLAUSE
 */
TOKEN :
{
    < KEYWORD_CREATE:   "CREATE" >
    |
    < KEYWORD_AS:       "AS"     >
}

/*
 * INSERT CLAUSE
 */
TOKEN :
{
    < KEYWORD_INSERT:   "INSERT" >
    |
    < KEYWORD_INTO:     "INTO" >
}

/*
 * EVERY CLAUSE
 */
TOKEN :
{
    < KEYWORD_EVERY:        "EVERY"        >
    |
    < KEYWORD_IN:           "IN"           >
}

/*
 * SELECT CLAUSE
 */
TOKEN :
{
    < KEYWORD_SELECT:    "SELECT"   >
    |
    // Virtual record field created by the GROUP BY clause
    <KEYWORD_GROUPTS:    "GROUP_TS" >
}

/*
 * WHERE CLAUSE
 */
TOKEN :
{
    < KEYWORD_WHERE:     "WHERE" >
}

/*
 * GROUP BY CLAUSE
 */
TOKEN :
{
    < KEYWORD_GROUP:     "GROUP"  >
    |
    < KEYWORD_BY:        "BY"     >
    |
    // Keyword employed to define the number of groups created by a timestamp
    // aggregation
    < KEYWORD_GROUPS:    "GROUPS" >
}

/*
 * HAVING CLAUSE
 */
TOKEN :
{
    < KEYWORD_HAVING:    "HAVING" >
}

/*
 * UP TO CLAUSE
 */
TOKEN :
{
    < KEYWORD_UP:        "UP" >
    |
    < KEYWORD_TO:        "TO" >
}

/*
 * ON EMPTY SELECTION CLAUSE
 */
TOKEN :
{
    < KEYWORD_ON:        "ON"        >
    |
    < KEYWORD_EMPTY:     "EMPTY"     >
    |
    < KEYWORD_SELECTION: "SELECTION" >
    |
//	< KEYWORD_INSERT:    "INSERT"    >
//  |
    < KEYWORD_NOTHING:   "NOTHING"   >
    |
    < KEYWORD_DEFAULT:   "DEFAULT"   >
}

/*
 * SAMPLING CLAUSE
 */
TOKEN :
{
    < KEYWORD_SAMPLING:  "SAMPLING" >
    |
//	< KEYWORD_ON:        "ON"       >
//  |
    < KEYWORD_EVENT:     "EVENT"    >
    |
//	< KEYWORD_IF:        "IF"       >
//  |
//	< KEYWORD_EVERY:     "EVERY"    >
//  |
    < KEYWORD_ELSE:      "ELSE"     >
}

/*
 * ON UNSUPPORTED SAMPLING RATE
 */
TOKEN :
{
//	< KEYWORD_ON:          "ON"          >
//  |
    < KEYWORD_UNSUPPORTED: "UNSUPPORTED" >
    |
    < KEYWORD_SAMPLE:      "SAMPLE"      >
    |
    < KEYWORD_RATE:        "RATE"        >
    |
    < KEYWORD_DO:          "DO"          >
    |
    < KEYWORD_SLOW:        "SLOW"        >
    |
    < KEYWORD_DOWN:        "DOWN"        >
}

/*
 * REFRESH CLAUSE
 */
TOKEN :
{
    < KEYWORD_REFRESH:   "REFRESH" >
    |
//	< KEYWORD_EVERY:     "EVERY"   >
//  |
    < KEYWORD_NEVER:     "NEVER"   >
}

/*
 * EXECUTE IF CLAUSE
 */
TOKEN :
{
    < KEYWORD_EXECUTE:        "EXECUTE"   >
    |
    < KEYWORD_IF:             "IF"        >
//  |
//  < KEYWORD_ON:			  "ON"        >
    |
    < KEYWORD_NODES:          "NODES"     >
    |
    < KEYWORD_WITH:           "WITH"      >
    |
    < KEYWORD_WITHOUT:        "WITHOUT"   >
    |
    < KEYWORD_ALL:            "ALL"       >
}

/*
 * TERMINATE AFTER CLAUSE
 */
TOKEN :
{
    < KEYWORD_TERMINATE:  "TERMINATE"  >
    |
    < KEYWORD_AFTER:      "AFTER"      >
    |
    < KEYWORD_SELECTIONS: "SELECTIONS" >
}

/*
 * FROM CLAUSE
 */
TOKEN :
{
    < KEYWORD_FROM:      "FROM" >
//  |
//	< KEYWORD_AS:        "AS"   >
}

/*
 * SET CLAUSE
 */
TOKEN :
{
    < KEYWORD_SET:    "SET"  >
//  |
//  < KEYWORD_ON: "ON"    >
}

/*
 * STREAM DATA STRUCTURE
 */
TOKEN :
{
    < KEYWORD_STREAM:   "STREAM"   >
}

/*
 * MISC TOKENS
 */
TOKEN :
{
    < KEYWORD_SAMPLES:  "SAMPLES"  >
    |
    < KEYWORD_ONE:      "ONE"      >
    |
    < KEYWORD_IS:       "IS" >
    |
    < KEYWORD_BETWEEN:  "BETWEEN"  >
    |
    < KEYWORD_LIKE:     "LIKE"     >
}

/*
 * ALGEBRAIC OPERATORS
 */
TOKEN :
{
    < OPERATOR_MULTIPLY: "*" >
    |
    < OPERATOR_DIVIDE:   "/" >
    |
    <OPERATOR_MODULO:    "%" >
    |
    < OPERATOR_PLUS:     "+" >
    |
    < OPERATOR_MINUS:    "-" >
}

/*
 * BOOLEAN OPERATORS
 */
TOKEN :
{
    < OPERATOR_NOT:     "NOT" >
    |
    < OPERATOR_XOR:     "XOR" >
    |
    < OPERATOR_AND:     "AND" >
    |
    < OPERATOR_OR:      "OR"  >
}

/*
 * BITWISE OPERATORS
 */
TOKEN :
{
    < OPERATOR_BITWISE_NOT: "~" >
    |
    < OPERATOR_BITWISE_LSH: "<<" >
    |
    < OPERATOR_BITWISE_RSH: ">>" >
    |
    < OPERATOR_BITWISE_XOR: "^" >
    |
    < OPERATOR_BITWISE_AND: "&" >
    |
    < OPERATOR_BITWISE_OR:  "|"  >
}

/*
 * COMPARISON OPERATORS
 */
TOKEN :
{
    < OPERATOR_GREATER:       ">"  >
    |
    < OPERATOR_LESS:          "<"  >
    |
    < OPERATOR_GREATER_EQUAL: ">=" >
    |
    < OPERATOR_LESS_EQUAL:    "<=" >
    |
    < OPERATOR_EQUAL:         "="  >
    |
    < OPERATOR_NOT_EQUAL:     "<>" | "!=" >
}

/*
 * AGGREGATES
 */
TOKEN :
{
    < FUNCTION_COUNT:     "COUNT"     >
    |
    < FUNCTION_AVG:       "AVG"       >
    |
    < FUNCTION_MAX:       "MAX"       >
    |
    < FUNCTION_MIN:       "MIN"       >
    |
    < FUNCTION_SUM:       "SUM"       >
}

/*
 * TIME UNITS
 */
TOKEN :
{
    < TIMEUNIT_S:  "seconds"      | "s"  >
    |
    < TIMEUNIT_M:  "minutes"      | "m"  >
    |
    < TIMEUNIT_H:  "hours"        | "h"  >
    |
    < TIMEUNIT_MS: "milliseconds" | "millis" | "ms" >
    |
    < TIMEUNIT_D:  "days"         | "d"  >
}

/*
 * DATA TYPES
 */
TOKEN :
{
    < TYPE_ID:             "ID"        >
    |
    < TYPE_TIMESTAMP:      "TIMESTAMP" >
    |
    < TYPE_BOOLEAN:        "BOOLEAN"   >
    |
    < TYPE_INTEGER:        "INTEGER"   >
    |
    < TYPE_FLOAT:          "FLOAT"     >
    |
    < TYPE_STRING:         "STRING"    >
}

/*
 * TYPE CLASS WILDCARDS
 */
TOKEN :
{
    < TYPE_ANY: "ANY" >
}

/*
 * COSTANTS
 * Don't use these tokens, use the corresponding productions instead.
 */

/*
 * CONSTANT NULL
 */
TOKEN :
{
    < CONSTANT_NULL:     "NULL" >
}

/*
 * 3-VALUE BOOLEAN LOGIC (true, false, unknown)
 */
TOKEN :
{
    < CONSTANT_BOOLEAN_TRUE:    "TRUE"    >
    |
    < CONSTANT_BOOLEAN_FALSE:   "FALSE"   >
    |
    < CONSTANT_BOOLEAN_UNKNOWN: "UNKNOWN" >
}

/*
 * NUMERIC CONSTANTS (float and integer)
 */
TOKEN :
{
    <CONSTANT_INTEGER_10: ( <DIGIT> )+ >
    |
    <CONSTANT_INTEGER_16: ( <HEXADECIMAL> ) >
    |
    <CONSTANT_FLOAT:
        ( <CONSTANT_INTEGER_10> )? "." <CONSTANT_INTEGER_10>
    >
}

/*
 * STRING CONSTANTS
 * Strings can be single quoted or double quoted. The quote character is
 * escaped when doubled (e.g., 'test '' string' or "test "" string"
 */
TOKEN :
{
    < CONSTANT_SINGLE_QUOTED_STRING_START: "'"  > : NON_SINGLE_QUOTED_STRING
    |
    < CONSTANT_DOUBLE_QUOTED_STRING_START: "\"" > : NON_DOUBLE_QUOTED_STRING
}

<NON_SINGLE_QUOTED_STRING> TOKEN :
{
    < CONSTANT_SINGLE_QUOTED_STRING_VALUE: (~["'"] | "'" "'")* > : NON_SINGLE_QUOTED_STRING_END
}

<NON_DOUBLE_QUOTED_STRING> TOKEN :
{
    < CONSTANT_DOUBLE_QUOTED_STRING_VALUE: (~["\""] | "\"" "\"")* > : NON_DOUBLE_QUOTED_STRING_END
}

<NON_SINGLE_QUOTED_STRING_END> TOKEN :
{
    < CONSTANT_SINGLE_QUOTED_STRING_END:  "'" > : DEFAULT
}

<NON_DOUBLE_QUOTED_STRING_END> TOKEN :
{
    < CONSTANT_DOUBLE_QUOTED_STRING_END: "\"" > : DEFAULT
}

/*
 * IDENTIFIERS
 */
TOKEN :
{
    < #DIGIT:      ["0" - "9"]               >
    |
    < #LITERAL:    ["a" - "z", "A" - "Z"] >
    |
    < #UNDERSCORE: "_"                       >
    |
    < #HEXADECIMAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
    |
    < IDENTIFIER: ( <LITERAL> | <UNDERSCORE>) ( <DIGIT> | <LITERAL> | <UNDERSCORE> )* >
}

/*
 * PRODUCTIONS
 */

Statement Statement(Errors err):
{
    Statement s;
}
{
    (
    s = SetParametersStament(err)
    |
    s = CreationStatement(err)
    |
    s = InsertionStatement(err)
    )
    { return s; }
}

SetStatement SetParametersStament(Errors err):
{
    int id;
    Set<Integer> ids = new TreeSet<Integer>();
    SetParameter p;
    List<SetParameter> params = new ArrayList<SetParameter>();
}
{
    <KEYWORD_SET>
    p = SetParameter(err)
    { params.add(p); }
    (
        ","
        p = SetParameter(err)
        { params.add(p); }
    )*
    <KEYWORD_ON>
    (
        id = ConstantInteger()
        { ids.add(id); }
    )
    (
        ","
        (
            id = ConstantInteger()
            { ids.add(id); }
        )
    )*
    { return null; }
}

SetParameter SetParameter(Errors err):
{
    String id;
    Expression e;
}
{
    id = Identifier()
    "="
    e = Expression(ExpressionType.CONSTANT, err, null)
    { return new SetParameter(id, e); }
}

CreationStatement CreationStatement(Errors err) :
{
    String name;
    List<FieldDefinition> fields;
    StreamDefinition stream;
    SelectionStatement sel = null;
}
{
    <KEYWORD_CREATE>
    <KEYWORD_STREAM>
    name = Identifier() // Stream name
    fields = FieldDefinitionList(err.inContext("Stream '" + name + "'"))
    [
        <KEYWORD_AS>
        sel = SelectionStatement(err)
    ]
    {
        stream = new StreamDefinition(name, fields);
        return new CreationStatement(stream, sel);
    }
}

List<FieldDefinition> FieldDefinitionList(Errors err) :
{
    List<FieldDefinition> fields = new ArrayList<FieldDefinition>();
    FieldDefinition f;

    Set<String> names = new TreeSet<String>();
}
{
    "("
    f = FieldDefinition(err)
    {
        names.add(f.getName());
        fields.add(f);
    }
    (
        ","
        f = FieldDefinition(err)
        {
            String n = f.getName();
            if (names.contains(n)) {
                err.addError("Duplicate field name '" + n + "'");
            } else {
                names.add(n);
            }
            fields.add(f);
        }
    )*
    ")"
    { return fields; }
}

FieldDefinition FieldDefinition(Errors err) :
{
    String name;
    DataType type;
    Expression e;
    Errors defErr;
    Object def = null;
}
{
    name = Identifier() // Data structure field
    type = Type()
    [
        <KEYWORD_DEFAULT>
        (
            e = Expression(ExpressionType.CONSTANT, err, null)
            {
                defErr = err.inContext("Illegal default value for field '" +
                    name + "' of type '" + type + "'.");
                def = ExpressionUtils.evaluateConstant(e, type, defErr);
            }
            |
            <CONSTANT_NULL>
        )
    ]
    { return new FieldDefinition(name, type, def); }
}

InsertionStatement InsertionStatement(Errors err) :
{
    String stream;
    List<String> fl = new ArrayList<String>();
    SelectionStatement sel;
}
{
    <KEYWORD_INSERT>
    <KEYWORD_INTO>
    <KEYWORD_STREAM>
    stream = Identifier() // Stream name
    [
        fl = FieldList(err)
    ]
    sel = SelectionStatement(err)
    { return new InsertionStatement(stream, fl, sel); }
}

List<String> FieldList(Errors err) :
{
    List<String> fl = new ArrayList<String>();
    String s;
}
{
    "("
    s = Identifier() // DataStructureField
    { fl.add(s); }
    (
        ","
        s = Identifier() // DataStructureField
        {
            if (fl.contains(s)) {
                err.addError("Duplicate field name '" + s + "'");
            }
            fl.add(s);
        }
    )*
    ")"
    { return fl; }
}

SelectionStatement SelectionStatement(Errors err) :
{
    // All attribute identifiers are incrementally stored inside this
    // structure, that is later employed by the EXECUTE IF clause when the
    // user requires all attributes referenced in the query
    Set<String> ids = new TreeSet<String>();

    WindowSize every;
    List<FieldSelection> fsl;
    GroupBy gby = GroupBy.NONE;
    Expression having = Constant.TRUE;
    WindowSize upto = WindowSize.ONE;
    OnEmptySelection oes = OnEmptySelection.INSERT_NOTHING;
    Sampling sampling;
    Select sel;
    Expression where = Constant.TRUE;
    ExecutionConditions ec = ExecutionConditions.ALL_NODES;
    WindowSize terminate = WindowSize.ZERO;
}
{
    every = EveryClause(err)
    <KEYWORD_SELECT>
    fsl = FieldSelectionList(err, ids)
    [
        gby = GroupByClause()
    ]
    [
        having = HavingClause(err, ids)
    ]
    [
        upto = UpToClause(err)
    ]
    [
        oes = OnEmptySelectionClause()
    ]
    {
        List<Expression> fields = new ArrayList<Expression>();
        Object[] def = new Object[fsl.size()];
        int i = 0;
        for (FieldSelection fs : fsl) {
            fields.add(fs.getField());
            def[i++] = fs.getDefault();
        }
        if (oes == OnEmptySelection.INSERT_NOTHING) {
            def = EMPTY_DEFAULT;
        }
        sel = new Select(fields, upto, gby, having, def);
    }
    sampling = SamplingClause(err, ids)
    [
        // This optional where clause filters the sampled values before adding
        // them to the local buffer
        <KEYWORD_WHERE>
        // No aggregates allowed
        where = Expression(ExpressionType.SIMPLE, err, ids)
    ]
    [
        ec = ExecutionConditionsClause(err, ids)
    ]
    [
        terminate = TerminateAfterClause(err)
    ]
    {
        return new SelectionStatement(sel, every, sampling,
                    where, ec, terminate);
    }
}

WindowSize EveryClause(Errors err) :
{
    WindowSize ws;
}
{
    <KEYWORD_EVERY>
    ws = WindowSize()
    { return ws; }
}

List<FieldSelection> FieldSelectionList(Errors err, Set<String> ids) :
{
    List<FieldSelection> fsl = new ArrayList<FieldSelection>();
    FieldSelection fs;
}
{
    fs = FieldSelection(err, ids)
    { fsl.add(fs); }
    (
        ","
        fs = FieldSelection(err, ids)
        { fsl.add(fs); }
    )*
    { return fsl; }
}

FieldSelection FieldSelection(Errors err, Set<String> ids) :
{
    Expression field;
    Object def = null;
}
{
    field = Expression(ExpressionType.AGGREGATE, err, ids)
    [
        <KEYWORD_DEFAULT>
        (
            def = Expression(ExpressionType.SIMPLE, err, ids)
            |
            <CONSTANT_NULL>
        )
    ]
    { return new FieldSelection(field, def); }
}

GroupBy GroupByClause() :
{
    GroupBy g;
}
{
    <KEYWORD_GROUP>
    <KEYWORD_BY>
    g = FieldGroupingByList()
    { return g; }
}

GroupBy FieldGroupingByList() :
{
    GroupByTS gts = null;
    Field f;
    List<Field> fs = new ArrayList<Field>();
}
{
    (
        f = FieldGroupingBy()
        { fs.add(f); }
        |
        gts = FieldGroupingByTs()
    )
    (
        ","
        f = FieldGroupingBy()
        { fs.add(f); }
    )*
    {
        if (gts == null) {
            return new GroupBy(fs);
        }
        return new GroupBy(gts.getDuration(), gts.getCount(), fs);
    }
}

Field FieldGroupingBy() :
{
    String f;
}
{
    f = Identifier() // FPC attribute
    { return new Field(f); }
}

GroupByTS FieldGroupingByTs() :
{
    Duration d;
    int count;
}
{
    <TYPE_TIMESTAMP>
    "("
    d = Duration()
    ","
    count = ConstantInteger()
    <KEYWORD_GROUPS>
    ")"
    { return new GroupByTS(d, count); }
}

Expression HavingClause(Errors err, Set<String> ids) :
{
    Expression e;
}
{
    <KEYWORD_HAVING>
    e = Expression(ExpressionType.AGGREGATE, err, ids)
    { return e; }
}

WindowSize UpToClause(Errors err) :
{
    WindowSize ws;
}
{
    <KEYWORD_UP>
    <KEYWORD_TO>
    ws = WindowSize()
    { return ws; }
}

OnEmptySelection OnEmptySelectionClause() :
{}
{
    <KEYWORD_ON>
    <KEYWORD_EMPTY>
    <KEYWORD_SELECTION>
    <KEYWORD_INSERT>
    (
        <KEYWORD_NOTHING>
        { return OnEmptySelection.INSERT_NOTHING; }
        |
        <KEYWORD_DEFAULT>
        { return OnEmptySelection.INSERT_DEFAULT; }
    )
}

Sampling SamplingClause(Errors err, Set<String> ids) :
{
    Set<String> events;

    IfEvery ife;
    RatePolicy policy = RatePolicy.DO_NOT_SAMPLE;
    Refresh refresh = Refresh.NEVER;
}
{
    <KEYWORD_SAMPLING>
    (
        events = OnEventClause()
        { return new SamplingEvent(events); }
        |
        (
            ife = IfEveryClause(err, ids)
            [
                policy = OnUnsupportedSRClause()
            ]
            [
                refresh = RefreshClause()
            ]
            { return new SamplingIfEvery(ife, policy, refresh); }
        )
    )
}

Set<String> OnEventClause() :
{
    Set<String> evs = new TreeSet<String>();
    String e;
}
{
    <KEYWORD_ON>
    <KEYWORD_EVENT>
    (
        e = Identifier() //FPC Event
        { evs.add(e); }
        (
            ","
            e = Identifier() // FPC Event
            { evs.add(e); }
        )*
    )
    { return evs; }
}

IfEvery IfEveryClause(Errors err, Set<String> ids) :
{
    IfEvery ife = null;
    IfEvery prev = null;

    Every every;
    Expression cond;
    Expression value;
    TemporalUnit unit;

    Errors subErr;
}
{
    (
        (
            <KEYWORD_IF>
            cond = Expression(ExpressionType.SIMPLE, err, ids)
            <KEYWORD_EVERY>
            every = EveryDuration(err, ids)
            {
                subErr = inContext(err, token);
                if (ife == null) {
                    ife = IfEvery.create(cond, every.getValue(),
                        every.getUnit(), subErr);
                    prev = ife;
                } else {
                    prev = IfEvery.create(prev, cond, every.getValue(),
                        every.getUnit(), subErr);
                }
            }
        )+
        (
            <KEYWORD_ELSE>
            <KEYWORD_EVERY>
            every = EveryDuration(err, ids)
            {
                subErr = inContext(err, token);
                prev = IfEvery.create(prev, Constant.TRUE, every.getValue(),
                    every.getUnit(), subErr);
            }
        )
        { return ife; }
    )
    |
    (
        <KEYWORD_EVERY>
        every = EveryDuration(err, ids)
        {
            subErr = inContext(err, token);
            ife = IfEvery.create(Constant.TRUE, every.getValue(),
                every.getUnit(), subErr);
        }
    )
    { return ife; }
}

Every EveryDuration(Errors err, Set<String> ids) :
{
    Expression value;
    TemporalUnit unit;
}
{
    value = Expression(ExpressionType.SIMPLE, err, ids)
    unit = TimeUnit()
    {
        return new Every(value, unit);
    }
}

RatePolicy OnUnsupportedSRClause() :
{}
{
    <KEYWORD_ON>
    <KEYWORD_UNSUPPORTED>
    <KEYWORD_SAMPLE>
    <KEYWORD_RATE>
    (
        <KEYWORD_DO>
        <OPERATOR_NOT>
        <KEYWORD_SAMPLE>
        { return RatePolicy.DO_NOT_SAMPLE; }
        |
        <KEYWORD_SLOW>
        <KEYWORD_DOWN>
        { return RatePolicy.SLOW_DOWN; }
    )
}

Refresh RefreshClause() :
{
    Set<String> es;
    Duration d;
}
{
    <KEYWORD_REFRESH>
    (
        es = OnEventClause()
        { return new Refresh(es); }
        |
        <KEYWORD_EVERY>
        d = Duration()
        { return new Refresh(d); }
        |
        <KEYWORD_NEVER>
        { return Refresh.NEVER; }
    )
}

ExecutionConditions ExecutionConditionsClause(Errors err, Set<String> ids) :
{
    Expression cond = Constant.TRUE;
    List<DataTemplate> specs = Collections.emptyList();
    Refresh r = Refresh.NEVER;
}
{
    <KEYWORD_EXECUTE>
    [
        <KEYWORD_IF>
        cond = Expression(ExpressionType.SIMPLE, err, ids)
    ]
    [
        specs = NodeSpecifications(ids)
    ]
    [
        r = RefreshClause()
    ]
    { return ExecutionConditions.create(cond, specs, r, err); }
}

List<DataTemplate> NodeSpecifications(Set<String> ids) :
{
    List<DataTemplate> specs;
}
{
    <KEYWORD_ON>
    <KEYWORD_NODES>
    <KEYWORD_WITH>
    (
        specs = SpecificationList()
        |
        <KEYWORD_ALL>
        {
            specs = new ArrayList<DataTemplate>();
            for (String id : ids) {
                specs.add(DataTemplate.create(id, TypeClass.ANY));
            }
        }
    )
    { return specs; }
}

List<DataTemplate> SpecificationList() :
{
    List<DataTemplate> ts = new ArrayList<DataTemplate>();
    DataTemplate t;
}
{
    t = Specification()
    { ts.add(t); }
    (
        ","
        t = Specification()
        { ts.add(t); }
    )*
    { return ts; }
}

DataTemplate Specification() :
{
    String id;
    TypeClass tc = TypeClass.ANY;
}
{
    id = Identifier()
    [
        ":"
        tc = TypeClass()
    ]
    { return DataTemplate.create(id, tc); }
}

WindowSize TerminateAfterClause(Errors err) :
{
    Duration d;
    int count;
}
{
    <KEYWORD_TERMINATE>
    <KEYWORD_AFTER>
    (
        LOOKAHEAD(2)
        d = Duration()
        { return new WindowSize(d); }
        |
        count = SelectionsNumber(err)
        { return new WindowSize(count); }
    )
}

/*
 * SIGNS, CONSTANTS, VALUES, ETC.
 */
Sign Sign() :
{}
{
    <OPERATOR_PLUS>
    { return Sign.PLUS; }
    |
    <OPERATOR_MINUS>
    { return Sign.MINUS; }
}

LogicValue ConstantBoolean() :
{}
{
    (
        <CONSTANT_BOOLEAN_TRUE>
        { return LogicValue.TRUE; }
        |
        <CONSTANT_BOOLEAN_FALSE>
        { return LogicValue.FALSE; }
    )
}

float ConstantFloat() :
{
    Token value;
}
{
    (
        value = <CONSTANT_FLOAT>
    )
    { return Float.parseFloat(value.image); }
}

int ConstantInteger() :
{
    Token value;
}
{
    value = <CONSTANT_INTEGER_10>
    { return Integer.parseInt(value.image); }
    |
    value = <CONSTANT_INTEGER_16>
    { return Integer.parseInt(value.image.substring(2), 16); }
}

String ConstantString() :
{
    Token value;
}
{
    (
        (
        <CONSTANT_SINGLE_QUOTED_STRING_START>
        value = <CONSTANT_SINGLE_QUOTED_STRING_VALUE>
        <CONSTANT_SINGLE_QUOTED_STRING_END>
        )
        |
        (
        <CONSTANT_DOUBLE_QUOTED_STRING_START>
        value = <CONSTANT_DOUBLE_QUOTED_STRING_VALUE>
        <CONSTANT_DOUBLE_QUOTED_STRING_END>
        )
    )
    { return value.image; }
}

ExpressionAST Constant() :
{
    Object value;
}
{
    (
        value = ConstantBoolean()
        { return new ConstantAST(token, DataType.BOOLEAN, value); }
        |
        value = ConstantString()
        { return new ConstantAST(token, DataType.STRING, value); }
        |
        LOOKAHEAD(1)
        value = ConstantInteger()
        { return new ConstantAST(token, DataType.INTEGER, value); }
        |
        value = ConstantFloat()
        { return new ConstantAST(token, DataType.FLOAT, value); }
    )
}

ComparisonOperation ComparisonOperation() :
{}
{
    <OPERATOR_GREATER>
    { return ComparisonOperation.GT; }
    |
    <OPERATOR_LESS>
    { return ComparisonOperation.LT; }
    |
    <OPERATOR_GREATER_EQUAL>
    { return ComparisonOperation.GE; }
    |
    <OPERATOR_LESS_EQUAL>
    { return ComparisonOperation.LE; }
    |
    <OPERATOR_EQUAL>
    { return ComparisonOperation.EQ; }
    |
    <OPERATOR_NOT_EQUAL>
    { return ComparisonOperation.NE; }
}

DataType Type() :
{}
{
    (
    <TYPE_ID>
    { return DataType.ID; }
    |
    <TYPE_TIMESTAMP>
    { return DataType.TIMESTAMP; }
    |
    <TYPE_BOOLEAN>
    { return DataType.BOOLEAN; }
    |
    <TYPE_INTEGER>
    { return DataType.INTEGER; }
    |
    <TYPE_FLOAT>
    { return DataType.FLOAT; }
    |
    <TYPE_STRING>
    { return DataType.STRING; }
    )
}

TypeClass TypeClass() :
{}
{
    (
    <TYPE_ID>
    { return TypeClass.ID; }
    |
    <TYPE_TIMESTAMP>
    { return TypeClass.TIMESTAMP; }
    |
    <TYPE_BOOLEAN>
    { return TypeClass.BOOLEAN; }
    |
    <TYPE_INTEGER>
    { return TypeClass.INTEGER; }
    |
    <TYPE_FLOAT>
    { return TypeClass.FLOAT; }
    |
    <TYPE_STRING>
    { return TypeClass.STRING; }
    |
    <TYPE_ANY>
    { return TypeClass.ANY; }
    )
}

TemporalUnit TimeUnit() :
{}
{
    <TIMEUNIT_S>
    { return ChronoUnit.SECONDS; }
    |
    <TIMEUNIT_M>
    { return ChronoUnit.MINUTES; }
    |
    <TIMEUNIT_H>
    { return ChronoUnit.HOURS; }
    |
    <TIMEUNIT_MS>
    { return ChronoUnit.MILLIS; }
    |
    <TIMEUNIT_D>
    { return ChronoUnit.DAYS; }
}

AggregateOperation AggregateOperation() :
{}
{
    <FUNCTION_AVG>
    { return AggregateOperation.AVG; }
    |
    <FUNCTION_MIN>
    { return AggregateOperation.MIN; }
    |
    <FUNCTION_MAX>
    { return AggregateOperation.MAX; }
    |
    <FUNCTION_SUM>
    { return AggregateOperation.SUM; }
}

Duration Duration() :
{
    TemporalUnit tu;
    int value;
}
{
    value = ConstantInteger()
    tu = TimeUnit()
    { return Duration.of(value, tu); }
}

int SamplesNumber() :
{
    int samples;
}
{
    (
        (
            samples = ConstantInteger()
            <KEYWORD_SAMPLES>
            { return samples; }
        )
        |
        (
            <KEYWORD_ONE>
            { return 1; }
        )
    )
}

int SelectionsNumber(Errors err) :
{

    Token t;
    int value;
}
{
    (
        value = ConstantInteger()
        { t = token; }
        <KEYWORD_SELECTIONS>
        {
            if (value == 0) {
                addError("Number of selections must be greater than zero", t, err);
            }
            return value;
        }
    )
}

WindowSize WindowSize() :
{
    Token t;
    Duration d;
    int samples;
    WindowSize ws;
}
{
    (
        LOOKAHEAD(2)
        d = Duration()
        {
            t = token;
            ws = new WindowSize(d);
        }
        |
        samples = SamplesNumber()
        {
            t = token;
            ws = new WindowSize(samples);
        }
    )
    { return ws; }
}

String Identifier() :
{
    Token value;
}
{
    value = <IDENTIFIER>
    { return value.image; }
}

/*
 * EXPRESSIONS
 */
ExpressionAST Expression() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BooleanTerm()
    (
        t = <OPERATOR_OR>
        e2 = BooleanTerm()
        { e1 = new BoolAST(t, BoolOperation.OR, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BooleanTerm() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BooleanFactor()
    (
        t = <OPERATOR_AND>
        e2 = BooleanFactor()
        { e1 = new BoolAST(t, BoolOperation.AND, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BooleanFactor() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BooleanNegation()
    (
        t = <OPERATOR_XOR>
        e2 = BooleanNegation()
        { e1 = new BoolAST(t, BoolOperation.XOR, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BooleanNegation() :
{
    ExpressionAST e;
    boolean invert = false;

    Token t = null;
}
{
    (
        t = <OPERATOR_NOT>
        {
            invert = !invert;
        }
    )*
    e = BooleanPredicate()
    {
        if (invert) {
            e = new BoolNotAST(t, e);
        }
        return e;
    }
}

ExpressionAST BooleanPredicate() :
{
    ExpressionAST e;
}
{
    e = Comparison()
    [
        e = Is(e)
        |
        e = Like(e)
        |
        e = Between(e)
    ]
    { return e; }
}

ExpressionAST Is(ExpressionAST e) :
{
    boolean invert = false;
    ExpressionAST is;

    Token t;
}
{
    t = <KEYWORD_IS>
    [
        <OPERATOR_NOT>
        { invert = true; }
    ]
    (
        <CONSTANT_BOOLEAN_TRUE>
        { is = new IsAST(t, e, LogicValue.TRUE); }
        |
        <CONSTANT_BOOLEAN_FALSE>
        { is = new IsAST(t, e, LogicValue.FALSE); }
        |
        <CONSTANT_BOOLEAN_UNKNOWN>
        { is = new IsAST(t, e, LogicValue.UNKNOWN); }
        |
        <CONSTANT_NULL>
        { is = new IsNullAST(t, e); }
    )
    {
        if (invert) {
            is = new BoolNotAST(t, e);
        }
        return is;
    }
}

ExpressionAST Like(ExpressionAST e) :
{
    String pattern;
    Expression like;

    Token t;
}
{
    t = <KEYWORD_LIKE>
    pattern = ConstantString()
    { return new LikeAST(t, e, pattern); }
}

ExpressionAST Between(ExpressionAST e) :
{
    ExpressionAST b;
    ExpressionAST min;
    ExpressionAST max;

    Token t;
}
{
    t = <KEYWORD_BETWEEN>
    min = BitwiseExpression()
    <OPERATOR_AND>
    max = BitwiseExpression()
    {
        return new BetweenAST(t, e, min, max);
    }
}

ExpressionAST Comparison() :
{
    ExpressionAST e1;
    ExpressionAST e2;
    ComparisonOperation op;

    Token t;
}
{
    e1 = BitwiseExpression()
    [
        op = ComparisonOperation()
        { t = token; }
        e2 = BitwiseExpression()
        {
            e1 = new ComparisonAST(t, op, e1, e2);
        }
    ]
    { return e1; }
}

ExpressionAST BitwiseExpression() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BitwiseTerm()
    (
        t = <OPERATOR_BITWISE_OR>
        e2 = BitwiseTerm()
        { e1 = new BitwiseAST(t, BitwiseOperation.OR, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BitwiseTerm() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BitwiseFactor()
    (
        t = <OPERATOR_BITWISE_AND>
        e2 = BitwiseFactor()
        { e1 = new BitwiseAST(t, BitwiseOperation.AND, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BitwiseFactor() :
{
    ExpressionAST e1;
    ExpressionAST e2;

    Token t;
}
{
    e1 = BitwiseShift()
    (
        t = <OPERATOR_BITWISE_XOR>
        e2 = BitwiseShift()
        { e1 = new BitwiseAST(t, BitwiseOperation.XOR, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BitwiseShift() :
{
    ExpressionAST e1;
    ExpressionAST e2;
    BitwiseOperation op;

    Token t;
}
{
    e1 = BitwiseNegation()
    (
        (
            t = <OPERATOR_BITWISE_LSH>
            { op = BitwiseOperation.LSH; }
            |
            t = <OPERATOR_BITWISE_RSH>
            { op = BitwiseOperation.RSH; }
        )
        e2 = BitwiseNegation()
        { e1 = new BitwiseAST(t, op, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST BitwiseNegation() :
{
    ExpressionAST e;
    boolean not = false;

    Token t = null;
}
{
    (
        t = <OPERATOR_BITWISE_NOT>
        { not = !not; }
    )*
    e = ArithmeticExpression()
    {
        if (not) {
            e = new BitwiseNotAST(t, e);
        }
        return e;
    }
}

ExpressionAST ArithmeticExpression() :
{
    ExpressionAST e1;
    ExpressionAST e2;
    ArithmeticOperation op;

    Token t;
}
{
    e1 = ArithmeticTerm()
    (
        (
            t = <OPERATOR_PLUS>
            { op = ArithmeticOperation.ADDITION; }
            |
            t = <OPERATOR_MINUS>
            { op = ArithmeticOperation.SUBTRACTION; }
        )
        e2 = ArithmeticTerm()
        { e1 = new ArithmeticAST(t, op, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST ArithmeticTerm() :
{
    ExpressionAST e1;
    ExpressionAST e2;
    ArithmeticOperation op;

    Token t;
}
{
    e1 = ArithmeticFactor()
    (
        (
            t = <OPERATOR_MULTIPLY>
            { op = ArithmeticOperation.PRODUCT; }
            |
            t = <OPERATOR_DIVIDE>
            { op = ArithmeticOperation.DIVISION; }
            |
            t = <OPERATOR_MODULO>
            { op = ArithmeticOperation.MODULO; }
        )
        e2 = ArithmeticFactor()
        { e1 = new ArithmeticAST(t, op, e1, e2); }
    )*
    { return e1; }
}

ExpressionAST ArithmeticFactor() :
{
    ExpressionAST e;
    Sign s = Sign.PLUS;

    Token t = null;
}
{
    [
        s = Sign()
        { t = token; }
    ]
    e = PrimaryExpression()
    {
        if (s == Sign.MINUS) {
            e = new ArithmeticInverseAST(t, e);
        }
        return e;
    }
}

ExpressionAST PrimaryExpression() :
{
    String id;
    ExpressionAST e;

    Token t = null;
}
{
    e = Constant()
    { return e; }
    |
    (
        "("
        e = Expression()
        { return e; }
        ")"
    )
    |
    t = <KEYWORD_GROUPTS>
    { return new GroupTSAST(t); }
    |
    e = Aggregate()
    { return e; }
    |
    id = Identifier() // FPC attribute
    { return new FieldAST(token, id); }
}

ExpressionAST Aggregate() :
{
    AggregateOperation op;
    ExpressionAST operand = ConstantAST.NULL;
    WindowSize ws;
    ExpressionAST filter = ConstantAST.TRUE;
    ExpressionAST e;

    Token t;
}
{
    (
        (
            t = <FUNCTION_COUNT>
            {
                op = AggregateOperation.COUNT;
            }
            "("
            "*"
            ","
            ws = WindowSize()
            [
                ","
                filter = Expression()
            ]
            ")"
        )
        |
        (
            op = AggregateOperation()
            { t = token; }
            "("
            operand = Expression()
            ","
            ws = WindowSize()
            [
                ","
                filter = Expression()
            ]
            ")"
        )
    )
    { return new AggregateAST(t, op, operand, ws, filter); }
}

