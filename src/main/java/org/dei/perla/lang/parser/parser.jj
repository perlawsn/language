/* Copyright (C) 2008  Romolo Camplani, Marco Fortunato, Marco Marelli, Guido Rota, Fabio A. Schreiber et al.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
options
{
    JDK_VERSION = "1.8";
    IGNORE_CASE = true;
    STATIC = false;
}

PARSER_BEGIN(Parser)

    package org.dei.perla.lang.parser;

    import java.time.temporal.TemporalUnit;
    import java.time.temporal.ChronoUnit;
    import java.time.Duration;
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Set;
    import java.util.TreeSet;

    import org.dei.perla.lang.executor.expression.*;
    import org.dei.perla.lang.executor.statement.*;
    import org.dei.perla.lang.executor.statement.IfEvery.ErrorIfEvery;

    import org.dei.perla.core.utils.Errors;
    import org.dei.perla.core.descriptor.DataType;
    import org.dei.perla.core.registry.TypeClass;
    import org.dei.perla.core.registry.DataTemplate;

	public final class Parser {

	    private static void addError(String msg, Token t, Errors err) {
	        err.addError("Line " + t.beginLine + ", Column " + t.beginColumn + ": " + msg);
	    }

	    private static void addIfError(Expression e, Token t, Errors err) {
	        if (!(e instanceof ErrorExpression)) {
	            return;
	        }
	        addError(((ErrorExpression) e).getError(), t, err);
	    }

	    private static void addIfError(IfEvery ife, Token t, Errors err) {
	    	if (!(ife instanceof ErrorIfEvery)) {
	    		return;
	    	}
	    	addError(((ErrorIfEvery) ife).getMessage(), t, err);
	    }

	}

PARSER_END(Parser)

/*
 * SEPARATORS
 */
SKIP :
{
 	" "
    |
	"\r"
    |
	"\t"
    |
	"\n"
}

/*
 *	COMMENTS
 */
MORE:
{
	"/*" : COMMENT
}

<COMMENT> MORE:
{
	<~[]>
}

<COMMENT> SKIP:
{
	"*/" : DEFAULT
}

/*
 * CREATE CLAUSE
 */
TOKEN :
{
	< KEYWORD_CREATE:   "CREATE" >
    |
	< KEYWORD_AS:       "AS"     >
}

/*
 * INSERT CLAUSE
 */
TOKEN :
{
	< KEYWORD_INSERT:   "INSERT" >
    |
	< KEYWORD_INTO:     "INTO" >
}

/*
 * EVERY CLAUSE
 */
TOKEN :
{
	< KEYWORD_EVERY:        "EVERY"        >
	|
	< KEYWORD_IN:           "IN"           >
}

/*
 * SELECT CLAUSE
 */
TOKEN :
{
	< KEYWORD_SELECT:    "SELECT"   >
    |
	// Virtual record field created by the GROUP BY clause
	<KEYWORD_GROUPTS:    "GROUP_TS" >
}

/*
 * WHERE CLAUSE
 */
TOKEN :
{
	< KEYWORD_WHERE:     "WHERE" >
}

/*
 * GROUP BY CLAUSE
 */
TOKEN :
{
	< KEYWORD_GROUP:     "GROUP"  >
    |
	< KEYWORD_BY:        "BY"     >
    |
    // Keyword employed to define the number of groups created by a timestamp
    // aggregation
	< KEYWORD_GROUPS:    "GROUPS" >
}

/*
 * HAVING CLAUSE
 */
TOKEN :
{
	< KEYWORD_HAVING:    "HAVING" >
}

/*
 * UP TO CLAUSE
 */
TOKEN :
{
	< KEYWORD_UP:        "UP" >
    |
	< KEYWORD_TO:        "TO" >
}

/*
 * ON EMPTY SELECTION CLAUSE
 */
TOKEN :
{
	< KEYWORD_ON:        "ON"        >
    |
	< KEYWORD_EMPTY:     "EMPTY"     >
    |
	< KEYWORD_SELECTION: "SELECTION" >
    |
//	< KEYWORD_INSERT:    "INSERT"    >
//  |
	< KEYWORD_NOTHING:   "NOTHING"   >
    |
	< KEYWORD_DEFAULT:   "DEFAULT"   >
}

/*
 * SAMPLING CLAUSE
 */
TOKEN :
{
	< KEYWORD_SAMPLING:  "SAMPLING" >
    |
//	< KEYWORD_ON:        "ON"       >
//  |
	< KEYWORD_EVENT:     "EVENT"    >
    |
//	< KEYWORD_IF:        "IF"       >
//  |
//	< KEYWORD_EVERY:     "EVERY"    >
//  |
	< KEYWORD_ELSE:      "ELSE"     >
}

/*
 * ON UNSUPPORTED SAMPLING RATE
 */
TOKEN :
{
//	< KEYWORD_ON:          "ON"          >
//  |
	< KEYWORD_UNSUPPORTED: "UNSUPPORTED" >
    |
	< KEYWORD_SAMPLE:      "SAMPLE"      >
    |
	< KEYWORD_RATE:        "RATE"        >
    |
	< KEYWORD_DO:          "DO"          >
    |
	< KEYWORD_SLOW:        "SLOW"        >
    |
	< KEYWORD_DOWN:        "DOWN"        >
}

/*
 * REFRESH CLAUSE
 */
TOKEN :
{
	< KEYWORD_REFRESH:   "REFRESH" >
    |
//	< KEYWORD_EVERY:     "EVERY"   >
//  |
	< KEYWORD_NEVER:     "NEVER"   >
}

/*
 * EXECUTE IF CLAUSE
 */
TOKEN :
{
	< KEYWORD_EXECUTE:        "EXECUTE"   >
    |
	< KEYWORD_IF:             "IF"        >
//  |
//  < KEYWORD_ON:			  "ON"        >
	|
	< KEYWORD_NODES:          "NODES"     >
	|
	< KEYWORD_WITH:           "WITH"      >
	|
	< KEYWORD_WITHOUT:        "WITHOUT"   >
	|
	< KEYWORD_ALL:            "ALL"       >
}

/*
 * TERMINATE AFTER CLAUSE
 */
TOKEN :
{
	< KEYWORD_TERMINATE:  "TERMINATE"  >
    |
	< KEYWORD_AFTER:      "AFTER"      >
    |
	< KEYWORD_SELECTIONS: "SELECTIONS" >
}

/*
 * FROM CLAUSE
 */
TOKEN :
{
	< KEYWORD_FROM:      "FROM" >
//  |
//	< KEYWORD_AS:        "AS"   >
}

/*
 * SET CLAUSE
 */
TOKEN :
{
  	< KEYWORD_SET:    "SET"  >
//  |
//  < KEYWORD_ON: "ON"    >
}

/*
 * STREAM DATA STRUCTURE
 */
TOKEN :
{
	< KEYWORD_STREAM:   "STREAM"   >
}

/*
 * MISC TOKENS
 */
TOKEN :
{
	< KEYWORD_SAMPLES:  "SAMPLES"  >
    |
	< KEYWORD_ONE:      "ONE"      >
    |
	< KEYWORD_IS:       "IS" >
    |
	< KEYWORD_BETWEEN:  "BETWEEN"  >
    |
	< KEYWORD_LIKE:     "LIKE"     >
}

/*
 * ALGEBRAIC OPERATORS
 */
TOKEN :
{
	< OPERATOR_MULTIPLY: "*" >
    |
	< OPERATOR_DIVIDE:   "/" >
	|
	<OPERATOR_MODULO:    "%" >
    |
	< OPERATOR_PLUS:     "+" >
    |
	< OPERATOR_MINUS:    "-" >
}

/*
 * BOOLEAN OPERATORS
 */
TOKEN :
{
	< OPERATOR_NOT:     "NOT" >
    |
	< OPERATOR_XOR:     "XOR" >
    |
	< OPERATOR_AND:     "AND" >
    |
    < OPERATOR_OR:      "OR"  >
}

/*
 * BITWISE OPERATORS
 */
TOKEN :
{
	< OPERATOR_BITWISE_NOT: "~" >
    |
	< OPERATOR_BITWISE_LSH: "<<" >
    |
	< OPERATOR_BITWISE_RSH: ">>" >
    |
    < OPERATOR_BITWISE_XOR: "^" >
    |
	< OPERATOR_BITWISE_AND: "&" >
    |
	< OPERATOR_BITWISE_OR:  "|"  >
}

/*
 * COMPARISON OPERATORS
 */
TOKEN :
{
	< OPERATOR_GREATER:       ">"  >
    |
	< OPERATOR_LESS:          "<"  >
    |
	< OPERATOR_GREATER_EQUAL: ">=" >
    |
	< OPERATOR_LESS_EQUAL:    "<=" >
    |
	< OPERATOR_EQUAL:         "="  >
    |
	< OPERATOR_NOT_EQUAL:     "<>" | "!=" >
}

/*
 * AGGREGATES
 */
TOKEN :
{
	< FUNCTION_COUNT:     "COUNT"     >
    |
	< FUNCTION_AVG:       "AVG"       >
    |
	< FUNCTION_MAX:       "MAX"       >
    |
	< FUNCTION_MIN:       "MIN"       >
    |
	< FUNCTION_SUM:       "SUM"       >
}

/*
 * TIME UNITS
 */
TOKEN :
{
	< TIMEUNIT_S:  "seconds"      | "s"  >
    |
	< TIMEUNIT_M:  "minutes"      | "m"  >
    |
	< TIMEUNIT_H:  "hours"        | "h"  >
    |
	< TIMEUNIT_MS: "milliseconds" | "ms" >
    |
	< TIMEUNIT_D:  "days"         | "d"  >
}

/*
 * DATA TYPES
 */
TOKEN :
{
	< TYPE_ID:             "ID"        >
    |
	< TYPE_TIMESTAMP:      "TIMESTAMP" >
    |
	< TYPE_BOOLEAN:        "BOOLEAN"   >
    |
	< TYPE_INTEGER:        "INTEGER"   >
    |
	< TYPE_FLOAT:          "FLOAT"     >
    |
	< TYPE_STRING:         "STRING"    >
}

/*
 * TYPE CLASS WILDCARDS
 */
TOKEN :
{
	< TYPE_ANY: "ANY" >
}

/*
 * COSTANTS
 * Don't use these tokens, use the corresponding productions instead.
 */

/*
 * CONSTANT NULL
 */
TOKEN :
{
	< CONSTANT_NULL:     "NULL" >
}

/*
 * 3-VALUE BOOLEAN LOGIC (true, false, unknown)
 */
TOKEN :
{
	< CONSTANT_BOOLEAN_TRUE:    "TRUE"    >
    |
	< CONSTANT_BOOLEAN_FALSE:   "FALSE"   >
    |
	< CONSTANT_BOOLEAN_UNKNOWN: "UNKNOWN" >
}

/*
 * NUMERIC CONSTANTS (float and integer)
 */
TOKEN :
{
	<CONSTANT_INTEGER_10: ( <DIGIT> )+ >
	|
	<CONSTANT_INTEGER_16: ( <HEXADECIMAL> ) >
    |
	<CONSTANT_FLOAT:
        ( <CONSTANT_INTEGER_10> )? "." <CONSTANT_INTEGER_10>
	>
}

/*
 * STRING CONSTANTS
 * Strings can be single quoted or double quoted. The quote character is
 * escaped when doubled (e.g., 'test '' string' or "test "" string"
 */
TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_START: "'"  > : NON_SINGLE_QUOTED_STRING
    |
	< CONSTANT_DOUBLE_QUOTED_STRING_START: "\"" > : NON_DOUBLE_QUOTED_STRING
}

<NON_SINGLE_QUOTED_STRING> TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_VALUE: (~["'"] | "'" "'")* > : NON_SINGLE_QUOTED_STRING_END
}

<NON_DOUBLE_QUOTED_STRING> TOKEN :
{
	< CONSTANT_DOUBLE_QUOTED_STRING_VALUE: (~["\""] | "\"" "\"")* > : NON_DOUBLE_QUOTED_STRING_END
}

<NON_SINGLE_QUOTED_STRING_END> TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_END:  "'" > : DEFAULT
}

<NON_DOUBLE_QUOTED_STRING_END> TOKEN :
{
	< CONSTANT_DOUBLE_QUOTED_STRING_END: "\"" > : DEFAULT
}

/*
 * IDENTIFIERS
 */
TOKEN :
{
	< #DIGIT:      ["0" - "9"]               >
    |
	< #LITERAL:    ["a" - "z", "A" - "Z"] >
    |
	< #UNDERSCORE: "_"                       >
    |
	< #HEXADECIMAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
    |
	< IDENTIFIER: ( <LITERAL> | <UNDERSCORE>) ( <DIGIT> | <LITERAL> | <UNDERSCORE> )* >
}

/*
 * PRODUCTIONS
 */

List<Statement> StatementSequence(Errors err) :
{
    List<Statement> sl = new ArrayList<Statement>();
    Statement s;
}
{
	s = Statement(err)
	{ sl.add(s); }
	(
		";"
		s = Statement(err)
		{ sl.add(s); }
	)*
	<EOF>
	{ return sl; }
}

Statement Statement(Errors err):
{
    Statement s;
}
{
    (
    s = SetParametersStament(err)
    |
    s = CreationStatement(err)
    |
    s = InsertionStatement(err)
    )
    { return s; }
}

Statement SetParametersStament(Errors err):
{}
{
    <KEYWORD_SET>
    SetParameterList(err)
  	(
        ","
  		SetParameterList(err)
  	)*
    <KEYWORD_ON>
	(
        <IDENTIFIER>
	    |
	    ConstantInteger()
	    |
	    ConstantString()
	)
	(
	    ","
	    (
		    <IDENTIFIER>
			|
			ConstantInteger()
			|
			ConstantString()
		)
	)*
	{ return null; }
}

void SetParameterList(Errors err):
{}
{
	Identifier()
	"="
	Expression(ExpressionType.CONSTANT, err, null)
}

Statement CreationStatement(Errors err) :
{}
{
	<KEYWORD_CREATE>
	<KEYWORD_STREAM>
	Identifier() // StreamName
	FieldDefinitionList(err)
	[
	    <KEYWORD_AS>
	    SelectionStatement(err)
	]
	{ return null; }
}

void FieldDefinitionList(Errors err) :
{}
{
	"("
	FieldDefinition(err)
	(
		","
		FieldDefinition(err)
	)*
	")"
}

void FieldDefinition(Errors err) :
{}
{
	Identifier() // Data structure field
	Type()
	[
		<KEYWORD_DEFAULT>
		Expression(ExpressionType.CONSTANT, err, null)
	]
}

Statement InsertionStatement(Errors err) :
{
    Selection sel;
}
{
	<KEYWORD_INSERT>
	<KEYWORD_INTO>
	<KEYWORD_STREAM>
	Identifier() // StreamName
	[
	    FieldList()
	]
	sel = SelectionStatement(err)
	{ return null; }
}

List<String> FieldList() :
{
    List<String> sl = new ArrayList<String>();
    String s;
}
{
	"("
	s = Identifier() // DataStructureField
	{ sl.add(s); }
	(
		","
		s = Identifier() // DataStructureField
		{ sl.add(s); }
	)*
	")"
	{ return sl; }
}

Selection SelectionStatement(Errors err) :
{
	List<String> ids = new ArrayList<String>();
    WindowSize every;
    List<FieldSelection> fsl;
    GroupBy gby = null;
    Expression having = null;
    WindowSize upto = WindowSize.ONE;
    OnEmptySelection oes = OnEmptySelection.INSERT_NOTHING;
    Sampling sampling;
    Expression where = null;
    WindowSize terminate = null;

    Select sel;
}
{
    every = EveryClause(err)
    <KEYWORD_SELECT>
    fsl = FieldSelectionList(err, ids)
	[
		gby = GroupByClause()
	]
	[
		having = HavingClause(err, ids)
	]
	[
		upto = UpToClause(err)
	]
	[
		oes = OnEmptySelectionClause()
	]
	{
	    List<Expression> fields = new ArrayList<Expression>();
	    Object[] def = new Object[fsl.size()];
	    int i = 0;
	    for (FieldSelection fs : fsl) {
	        fields.add(fs.getField());
	        def[i++] = fs.getDefault();
	    }
	    if (oes == OnEmptySelection.INSERT_NOTHING) {
	        def = null;
	    }
	    sel = new Select(fields, upto, gby, having, def);
	}
	sampling = SamplingClause(err, ids)
	[
		// This optional where clause filters the sampled values before adding
		// them to the local buffer
	    <KEYWORD_WHERE>
	    // No aggregates allowed
	    where = Expression(ExpressionType.SIMPLE, err, ids)
	]
	[
		ExecutionConditionsClause(err, ids)
	]
	[
		terminate = TerminateAfterClause(err)
	]
	{ return null; }
}

WindowSize EveryClause(Errors err) :
{
    WindowSize ws;
}
{
	<KEYWORD_EVERY>
	ws = WindowSize(err)
	{ return ws; }
}

List<FieldSelection> FieldSelectionList(Errors err, List<String> ids) :
{
    List<FieldSelection> fsl = new ArrayList<FieldSelection>();
    FieldSelection fs;
}
{
	fs = FieldSelection(err, ids)
	{ fsl.add(fs); }
	(
		","
		fs = FieldSelection(err, ids)
		{ fsl.add(fs); }
	)*
	{ return fsl; }
}

FieldSelection FieldSelection(Errors err, List<String> ids) :
{
    Expression field;
    Object def = null;
}
{
	field = Expression(ExpressionType.AGGREGATE, err, ids)
	[
		<KEYWORD_DEFAULT>
		(
            def = Expression(ExpressionType.SIMPLE, err, ids)
            |
            <CONSTANT_NULL>
		)
	]
	{ return new FieldSelection(field, def); }
}

GroupBy GroupByClause() :
{
    GroupBy g;
}
{
	<KEYWORD_GROUP>
	<KEYWORD_BY>
	g = FieldGroupingByList()
	{ return g; }
}

GroupBy FieldGroupingByList() :
{
    GroupByTS gts = null;
    Field f;
    List<Field> fs = new ArrayList<Field>();
}
{
	(
		f = FieldGroupingBy()
		{ fs.add(f); }
		|
		gts = FieldGroupingByTs()
	)
	(
		","
		f = FieldGroupingBy()
		{ fs.add(f); }
	)*
	{
	    if (gts == null) {
	        return new GroupBy(fs);
	    }
	    return new GroupBy(gts.getDuration(), gts.getCount(), fs);
	}
}

Field FieldGroupingBy() :
{
    String f;
}
{
	f = Identifier() // FPC attribute
	{ return new Field(f); }
}

GroupByTS FieldGroupingByTs() :
{
    Duration d;
    int count;
}
{
	<TYPE_TIMESTAMP>
	"("
	d = Duration()
	","
	count = ConstantInteger()
	<KEYWORD_GROUPS>
	")"
	{ return new GroupByTS(d, count); }
}

Expression HavingClause(Errors err, List<String> ids) :
{
    Expression e;
}
{
	<KEYWORD_HAVING>
	e = Expression(ExpressionType.AGGREGATE, err, ids)
	{ return e; }
}

WindowSize UpToClause(Errors err) :
{
    WindowSize ws;
}
{
	<KEYWORD_UP>
	<KEYWORD_TO>
	ws = WindowSize(err)
	{ return ws; }
}

OnEmptySelection OnEmptySelectionClause() :
{}
{
	<KEYWORD_ON>
	<KEYWORD_EMPTY>
	<KEYWORD_SELECTION>
	<KEYWORD_INSERT>
	(
		<KEYWORD_NOTHING>
		{ return OnEmptySelection.INSERT_NOTHING; }
		|
	 	<KEYWORD_DEFAULT>
	 	{ return OnEmptySelection.INSERT_DEFAULT; }
	)
}

Sampling SamplingClause(Errors err, List<String> ids) :
{
	Set<String> events;

	IfEvery ife;
	RatePolicy policy = RatePolicy.DO_NOT_SAMPLE;
	Refresh refresh = null;
}
{
	<KEYWORD_SAMPLING>
	(
		events = OnEventClause()
		{ return new SamplingEvent(events); }
		|
		(
			ife = IfEveryClause(err, ids)
			[
				policy = OnUnsupportedSRClause()
			]
			[
				refresh = RefreshClause()
			]
			{ return new SamplingIfEvery(ife, policy, refresh); }
		)
	)
}

Set<String> OnEventClause() :
{
    Set<String> evs = new TreeSet<String>();
    String e;
}
{
	<KEYWORD_ON>
	<KEYWORD_EVENT>
	(
	    e = Identifier() //FPC Event
	    { evs.add(e); }
	    (
	        ","
	        e = Identifier() // FPC Event
	        { evs.add(e); }
	    )*
    )
	{ return evs; }
}

IfEvery IfEveryClause(Errors err, List<String> ids) :
{
    IfEvery ife = null;
    IfEvery prev = null;

    Every every;
    Expression cond;
    Expression value;
    TemporalUnit unit;

    Token t;
}
{
	(
		(
		    <KEYWORD_IF>
		    cond = Expression(ExpressionType.SIMPLE, err, ids)
		    <KEYWORD_EVERY>
		    every = EveryDuration(err, ids)
		    {
		        if (ife == null) {
		            ife = IfEvery.create(cond, every.getValue(),
		                every.getUnit());
		            addIfError(ife, token, err);
		            prev = ife;
		        } else {
                    prev = IfEvery.create(prev, cond, every.getValue(),
                        every.getUnit());
		        }
		    }
		)+
		(
			<KEYWORD_ELSE>
			<KEYWORD_EVERY>
			every = EveryDuration(err, ids)
			{
			    prev = IfEvery.create(prev, Constant.TRUE, every.getValue(),
			        every.getUnit());
			    addIfError(prev, token, err);
			}
		)
		{ return ife; }
	)
	|
	(
	    <KEYWORD_EVERY>
	    every = EveryDuration(err, ids)
	    {
	        ife = IfEvery.create(Constant.TRUE, every.getValue(),
	            every.getUnit());
	        addIfError(ife, token, err);
	    }
	)
	{ return ife; }
}

Every EveryDuration(Errors err, List<String> ids) :
{
    Expression value;
    TemporalUnit unit;
}
{
    value = Expression(ExpressionType.SIMPLE, err, ids)
    unit = TimeUnit()
    {
        return new Every(value, unit);
    }
}

RatePolicy OnUnsupportedSRClause() :
{}
{
	<KEYWORD_ON>
	<KEYWORD_UNSUPPORTED>
	<KEYWORD_SAMPLE>
	<KEYWORD_RATE>
	(
		<KEYWORD_DO>
		<OPERATOR_NOT>
		<KEYWORD_SAMPLE>
		{ return RatePolicy.DO_NOT_SAMPLE; }
        |
		<KEYWORD_SLOW>
		<KEYWORD_DOWN>
		{ return RatePolicy.SLOW_DOWN; }
	)
}

Refresh RefreshClause() :
{
    Set<String> es;
    Duration d;
}
{
	<KEYWORD_REFRESH>
	(
        es = OnEventClause()
        { return new Refresh(es); }
		|
        <KEYWORD_EVERY>
        d = Duration()
        { return new Refresh(d); }
		|
        <KEYWORD_NEVER>
        { return null; }
	)
}

ExecutionConditions ExecutionConditionsClause(Errors err, List<String> ids) :
{
    Expression cond = null;
    List<DataTemplate> specs = null;
    Refresh r = null;
}
{
	<KEYWORD_EXECUTE>
	[
        <KEYWORD_IF>
        cond = Expression(ExpressionType.SIMPLE, err, ids)
	]
	[
		specs = NodeSpecifications(ids)
    ]
	[
		r = RefreshClause()
	]
	{ return new ExecutionConditions(cond, specs, r); }
}

List<DataTemplate> NodeSpecifications(List<String> ids) :
{
	List<DataTemplate> specs;
}
{
    <KEYWORD_ON>
    <KEYWORD_NODES>
    <KEYWORD_WITH>
    (
        specs = SpecificationList()
        |
        <KEYWORD_ALL>
        {
            specs = new ArrayList<DataTemplate>();
            for (String id : ids) {
                specs.add(DataTemplate.create(id, TypeClass.ANY));
            }
        }
    )
    { return specs; }
}

List<DataTemplate> SpecificationList() :
{
	List<DataTemplate> ts = new ArrayList<DataTemplate>();
	DataTemplate t;
}
{
	t = Specification()
	{ ts.add(t); }
	(
		","
		t = Specification()
        { ts.add(t); }
	)*
	{ return ts; }
}

DataTemplate Specification() :
{
	String id;
	TypeClass tc = TypeClass.ANY;
}
{
	id = Identifier()
	[
        ":"
        tc = TypeClass()
    ]
	{ return DataTemplate.create(id, tc); }
}

WindowSize TerminateAfterClause(Errors err) :
{
    Duration d;
    int count;
}
{
	<KEYWORD_TERMINATE>
	<KEYWORD_AFTER>
	(
		LOOKAHEAD(2)
		d = Duration()
		{ return new WindowSize(d); }
		|
		count = SelectionsNumber(err)
		{ return new WindowSize(count); }
	)
}

/*
 * SIGNS, CONSTANTS, VALUES, ETC.
 */
Sign Sign() :
{}
{
	<OPERATOR_PLUS>
	{ return Sign.PLUS; }
	|
	<OPERATOR_MINUS>
	{ return Sign.MINUS; }
}

LogicValue ConstantBoolean() :
{}
{
	(
		<CONSTANT_BOOLEAN_TRUE>
		{ return LogicValue.TRUE; }
		|
		<CONSTANT_BOOLEAN_FALSE>
		{ return LogicValue.FALSE; }
	)
}

float ConstantFloat() :
{
    Token value;
}
{
	(
		value = <CONSTANT_FLOAT>
	)
	{ return Float.parseFloat(value.image); }
}

int ConstantInteger() :
{
    Token value;
}
{
	value = <CONSTANT_INTEGER_10>
	{ return Integer.parseInt(value.image); }
	|
	value = <CONSTANT_INTEGER_16>
	{ return Integer.parseInt(value.image.substring(2), 16); }
}

String ConstantString() :
{
    Token value;
}
{
	(
		(
		<CONSTANT_SINGLE_QUOTED_STRING_START>
		value = <CONSTANT_SINGLE_QUOTED_STRING_VALUE>
		<CONSTANT_SINGLE_QUOTED_STRING_END>
		)
		|
		(
		<CONSTANT_DOUBLE_QUOTED_STRING_START>
		value = <CONSTANT_DOUBLE_QUOTED_STRING_VALUE>
		<CONSTANT_DOUBLE_QUOTED_STRING_END>
		)
	)
	{ return value.image; }
}

Expression Constant() :
{
    Object value;
}
{
	(
		value = ConstantBoolean()
		{ return Constant.create(value, DataType.BOOLEAN); }
		|
		value = ConstantString()
		{ return Constant.create(value, DataType.STRING); }
		|
		LOOKAHEAD(1)
		value = ConstantInteger()
		{ return Constant.create(value, DataType.INTEGER); }
		|
		value = ConstantFloat()
		{ return Constant.create(value, DataType.FLOAT); }
	)
}

ComparisonOperation ComparisonOperation() :
{}
{
	<OPERATOR_GREATER>
	{ return ComparisonOperation.GT; }
	|
	<OPERATOR_LESS>
	{ return ComparisonOperation.LT; }
	|
	<OPERATOR_GREATER_EQUAL>
	{ return ComparisonOperation.GE; }
	|
	<OPERATOR_LESS_EQUAL>
	{ return ComparisonOperation.LE; }
	|
	<OPERATOR_EQUAL>
	{ return ComparisonOperation.EQ; }
	|
	<OPERATOR_NOT_EQUAL>
	{ return ComparisonOperation.NE; }
}

DataType Type() :
{}
{
	(
	<TYPE_ID>
	{ return DataType.ID; }
	|
	<TYPE_TIMESTAMP>
	{ return DataType.TIMESTAMP; }
	|
	<TYPE_BOOLEAN>
	{ return DataType.BOOLEAN; }
	|
	<TYPE_INTEGER>
	{ return DataType.INTEGER; }
	|
	<TYPE_FLOAT>
	{ return DataType.FLOAT; }
	|
	<TYPE_STRING>
	{ return DataType.STRING; }
	)
}

TypeClass TypeClass() :
{}
{
	(
	<TYPE_ID>
	{ return TypeClass.ID; }
	|
	<TYPE_TIMESTAMP>
	{ return TypeClass.TIMESTAMP; }
	|
	<TYPE_BOOLEAN>
	{ return TypeClass.BOOLEAN; }
	|
	<TYPE_INTEGER>
	{ return TypeClass.INTEGER; }
	|
	<TYPE_FLOAT>
	{ return TypeClass.FLOAT; }
	|
	<TYPE_STRING>
	{ return TypeClass.STRING; }
	|
	<TYPE_ANY>
	{ return TypeClass.ANY; }
	)
}

TemporalUnit TimeUnit() :
{}
{
	<TIMEUNIT_S>
	{ return ChronoUnit.SECONDS; }
	|
	<TIMEUNIT_M>
	{ return ChronoUnit.MINUTES; }
	|
	<TIMEUNIT_H>
	{ return ChronoUnit.HOURS; }
	|
	<TIMEUNIT_MS>
	{ return ChronoUnit.MILLIS; }
	|
	<TIMEUNIT_D>
	{ return ChronoUnit.DAYS; }
}

AggregateOperation AggregateOperation() :
{}
{
	<FUNCTION_AVG>
	{ return AggregateOperation.AVG; }
	|
	<FUNCTION_MIN>
	{ return AggregateOperation.MIN; }
	|
	<FUNCTION_MAX>
	{ return AggregateOperation.MAX; }
	|
	<FUNCTION_SUM>
	{ return AggregateOperation.SUM; }
}

Duration Duration() :
{
    TemporalUnit tu;
    int value;
}
{
	value = ConstantInteger()
	tu = TimeUnit()
    { return Duration.of(value, tu); }
}

int SamplesNumber() :
{
    int samples;
}
{
	(
		(
			samples = ConstantInteger()
			<KEYWORD_SAMPLES>
			{ return samples; }
		)
		|
		(
			<KEYWORD_ONE>
			{ return 1; }
		)
	)
}

int SelectionsNumber(Errors err) :
{

    Token t;
    int value;
}
{
	(
		value = ConstantInteger()
		{ t = token; }
		<KEYWORD_SELECTIONS>
		{
		    if (value == 0) {
		        addError("Number of selections must be greater than zero", t, err);
		    }
		    return value;
		}
	)
}

WindowSize WindowSize(Errors err) :
{
    Token t;
    Duration d;
    int samples;
    WindowSize ws;
}
{
    (
	    LOOKAHEAD(2)
	    d = Duration()
	    {
	        t = token;
	        ws = new WindowSize(d);
	    }
	    |
        samples = SamplesNumber()
        {
            t = token;
            ws = new WindowSize(samples);
        }
	)
	{
	    if (ws.isZero()) {
	        addError("Empty window size", t, err);
	    }
	    return ws;
	}
}

String Identifier() :
{
    Token value;
}
{
	value = <IDENTIFIER>
	{ return value.image; }
}

/*
 * EXPRESSIONS
 */
Expression Expression(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BooleanTerm(type, err, ids)
	(
		<OPERATOR_OR>
		e2 = BooleanTerm(type, err, ids)
		{
		    e1 = Bool.createOR(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BooleanTerm(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BooleanFactor(type, err, ids)
	(
		<OPERATOR_AND>
		e2 = BooleanFactor(type, err, ids)
		{
		    e1 = Bool.createAND(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BooleanFactor(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BooleanNegation(type, err, ids)
	(
		<OPERATOR_XOR>
		e2 = BooleanNegation(type, err, ids)
		{
		    e1 = Bool.createXOR(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BooleanNegation(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e;
    boolean invert = false;
}
{
	(
		<OPERATOR_NOT>
		{ invert = true; }
	)*
	e = BooleanPredicate(type, err, ids)
	{
	    if (invert) {
	        return Bool.createNOT(e);
	        addIfError(e, token, err);
	    }
	    return e;
	}
}

Expression BooleanPredicate(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e;
}
{
    e = Comparison(type, err, ids)
    [
        e = Is(e, err)
        |
        e = Like(e, err)
        |
        e = Between(e, type, err, ids)
    ]
    { return e; }
}

Expression Is(Expression e, Errors err) :
{
    boolean invert = false;
    Expression is;
}
{
    <KEYWORD_IS>
    [
        <OPERATOR_NOT>
        { invert = true; }
    ]
    (
        <CONSTANT_BOOLEAN_TRUE>
        { is = Is.create(e, LogicValue.TRUE); }
        |
        <CONSTANT_BOOLEAN_FALSE>
        { is = Is.create(e, LogicValue.FALSE); }
        |
        <CONSTANT_BOOLEAN_UNKNOWN>
        { is = Is.create(e, LogicValue.UNKNOWN); }
        |
        <CONSTANT_NULL>
        { is = IsNull.create(e); }
    )
    {
        addIfError(is, token, err);
        if (invert) {
            is = Bool.createNOT(is);
            addIfError(is, token, err);
        }
        return is;
    }
}

Expression Like(Expression e, Errors err) :
{
    String pattern;
    Expression like;
}
{
    <KEYWORD_LIKE>
    pattern = ConstantString()
    {
        like = Like.create(e, pattern);
        addIfError(like, token, err);
        return like;
    }
}

Expression Between(Expression e, ExpressionType type, Errors err, List<String> ids) :
{
    Expression b;
    Expression min;
    Expression max;
}
{
    <KEYWORD_BETWEEN>
    min = BitwiseExpression(type, err, ids)
    <OPERATOR_AND>
    max = BitwiseExpression(type, err, ids)
    {
        b = Between.create(e, min, max);
        addIfError(b, token, err);
        return b;
    }
}

Expression Comparison(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
    ComparisonOperation op;
}
{
    e1 = BitwiseExpression(type, err, ids)
    [
        op = ComparisonOperation()
        e2 = BitwiseExpression(type, err, ids)
        {
            e1 = Comparison.create(op, e1, e2);
            addIfError(e1, token, err);
        }
    ]
    { return e1; }
}

Expression BitwiseExpression(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BitwiseTerm(type, err, ids)
	(
		<OPERATOR_BITWISE_OR>
		e2 = BitwiseTerm(type, err, ids)
		{
		    e1 = Bitwise.createOR(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BitwiseTerm(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BitwiseFactor(type, err, ids)
	(
		<OPERATOR_BITWISE_AND>
		e2 = BitwiseFactor(type, err, ids)
		{
		    e1 = Bitwise.createAND(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BitwiseFactor(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
}
{
	e1 = BitwiseShift(type, err, ids)
	(
		<OPERATOR_BITWISE_XOR>
		e2 = BitwiseShift(type, err, ids)
		{
		    e1 = Bitwise.createXOR(e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression BitwiseShift(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
    BitwiseOperation op;
}
{
	e1 = BitwiseNegation(type, err, ids)
	[
		(
			<OPERATOR_BITWISE_LSH>
			{ op = BitwiseOperation.LSH; }
			|
			<OPERATOR_BITWISE_RSH>
			{ op = BitwiseOperation.RSH; }
		)
		e2 = BitwiseNegation(type, err, ids)
		{
		    e1 = Bitwise.create(op, e1, e2);
		    addIfError(e1, token, err);
		}
	]
	{ return e1; }
}

Expression BitwiseNegation(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e;
    boolean not = false;
}
{
	(
		<OPERATOR_BITWISE_NOT>
		{ not = true; }
	)*
	e = ArithmeticExpression(type, err, ids)
	{
	    if (not) {
	        e = Bitwise.createNOT(e);
	        addIfError(e, token, err);
	    }
	    return e;
	}
}

Expression ArithmeticExpression(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
    ArithmeticOperation op;
}
{
	e1 = ArithmeticTerm(type, err, ids)
	(
		(
			<OPERATOR_PLUS>
			{ op = ArithmeticOperation.ADDITION; }
			|
			<OPERATOR_MINUS>
			{ op = ArithmeticOperation.SUBTRACTION; }
		)
		e2 = ArithmeticTerm(type, err, ids)
		{
		    e1 = Arithmetic.create(op, e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression ArithmeticTerm(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e1;
    Expression e2;
    ArithmeticOperation op;
}
{
	e1 = ArithmeticFactor(type, err, ids)
	(
		(
			<OPERATOR_MULTIPLY>
			{ op = ArithmeticOperation.PRODUCT; }
			|
			<OPERATOR_DIVIDE>
			{ op = ArithmeticOperation.DIVISION; }
			|
			<OPERATOR_MODULO>
			{ op = ArithmeticOperation.MODULO; }
		)
		e2 = ArithmeticFactor(type, err, ids)
		{
		    e1 = Arithmetic.create(op, e1, e2);
		    addIfError(e1, token, err);
		}
	)*
	{ return e1; }
}

Expression ArithmeticFactor(ExpressionType type, Errors err, List<String> ids) :
{
    Expression e;
    Sign s = Sign.PLUS;
}
{
	[
		s = Sign()
	]
	e = PrimaryExpression(type, err, ids)
	{
	    if (s == Sign.MINUS) {
	        e = Arithmetic.createInverse(e);
	        addIfError(e, token, err);
	    }
	    return e;
	}
}

Expression PrimaryExpression(ExpressionType type, Errors err, List<String> ids) :
{
    String id;
    Expression e;
}
{
	e = Constant()
	{
	    addIfError(e, token, err);
	    return e;
	}
	|
	(
	"("
        e = Expression(type, err, ids)
        {
            addIfError(e, token, err);
            return e;
        }
        ")"
	)
	|
    <KEYWORD_GROUPTS>
    {
        if (type != ExpressionType.AGGREGATE) {
        	String msg = "aggregation not allowed";
            addError(msg, token, err);
            return new ErrorExpression(msg);
        }
        ids.add("timestamp");
        return new GroupTS();
    }
    |
    e = Aggregate(err, ids)
    {
        if (type != ExpressionType.AGGREGATE) {
        	String msg = "aggregation not allowed";
            addError(msg, token, err);
            return new ErrorExpression(msg);
        }
        return e;
    }
    |
    id = Identifier() // FPC attribute
    {
    	if (type == ExpressionType.CONSTANT) {
    		String msg = "attributes not allowed in constant expression";
    		addError(msg, token, err);
    		return new ErrorExpression(msg);
    	}
    	ids.add(id);
    	return new Field(id);
    }
}

Expression Aggregate(Errors err, List<String> ids) :
{
    Token t;
    AggregateOperation op;
    Expression exp = null;
    WindowSize ws;
    Expression filter = null;
    Expression e;
}
{
    (
        (
            <FUNCTION_COUNT>
            { t = token; }
            { op = AggregateOperation.COUNT; }
            "("
            "*"
            ","
            ws = WindowSize(err)
            [
                ","
                filter = Expression(ExpressionType.SIMPLE, err, ids)
            ]
            ")"
        )
        |
        (
            op = AggregateOperation()
            { t = token; }
            "("
            exp = Expression(ExpressionType.SIMPLE, err, ids)
            ","
            ws = WindowSize(err)
            [
                ","
                filter = Expression(ExpressionType.SIMPLE, err, ids)
            ]
            ")"
        )
    )
    {
        e = Aggregate.create(op, exp, ws, filter);
        addIfError(e, t, err);
        return e;
    }
}

