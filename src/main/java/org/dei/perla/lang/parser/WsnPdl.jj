/* Copyright (C) 2008  Romolo Camplani, Marco Fortunato, Marco Marelli, Guido Rota, Fabio A. Schreiber et al.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
options
{
  JDK_VERSION = "1.8";
  IGNORE_CASE = true;
}

PARSER_BEGIN(Parser)

	public class Parser {

	}

PARSER_END(Parser)

/*
 * SEPARATORS
 */
SKIP :
{
 	" "
|
	"\r"
|
	"\t"
|
	"\n"
}

/*
 *	COMMENTS
 */
MORE:
{
	"/*" : COMMENT
}

<COMMENT> MORE:
{
	<~[]>
}

<COMMENT> SKIP:
{
	"*/" : DEFAULT
}

TOKEN :
{
/*
 * CREATE CLAUSE
 */
	< KEYWORD_CREATE:   "CREATE" >
    |
	< KEYWORD_OUTPUT:   "OUTPUT" >
    |
	< KEYWORD_AS:       "AS"     >
    |

/*
 * INSERT CLAUSE
 */
	< KEYWORD_INSERT:   "INSERT" >
    |
	< KEYWORD_INTO:     "INTO" >
	|

/*
 * EVERY CLAUSE
 */
	< KEYWORD_EVERY:        "EVERY"        >
	|
	< KEYWORD_SYNCHRONIZED: "SYNCHRONIZED" >
	|
	< KEYWORD_IN:           "IN"           >
	|

/*
 * SELECT CLAUSE
 */
	< KEYWORD_SELECT:    "SELECT"   >
    |
	< KEYWORD_DISTINCT:  "DISTINCT" >
    |
	< KEYWORD_ALL:       "ALL"      >
    |
	// Virtual record field created by the GROUP BY clause
	<KEYWORD_GROUPTS:    "GROUP_TS" >
    |

/*
 * UNION CLAUSE
 */
	< KEYWORD_UNION:     "UNION" >
//  |
//	< KEYWORD_ALL:       "ALL"   >
    |

/*
 * WHERE CLAUSE  */
	< KEYWORD_WHERE:     "WHERE" >
    |

/*
 * GROUP BY CLAUSE
 */
	< KEYWORD_GROUP:     "GROUP"  >
    |
	< KEYWORD_BY:        "BY"     >
//  |
//	< KEYWORD_ALL:       "ALL"    >
    |
    // Keyword employed to define the number of groups created by a timestamp
    // aggregation
	< KEYWORD_GROUPS:    "GROUPS" >
	|

/*
 * HAVING CLAUSE
 */
	< KEYWORD_HAVING:    "HAVING" >
    |

/*
 * UP TO CLAUSE
 */
	< KEYWORD_UP:        "UP" >
    |
	< KEYWORD_TO:        "TO" >
	|

/*
 * ON EMPTY SELECTION CLAUSE
 */
	< KEYWORD_ON:        "ON"        >
    |
	< KEYWORD_EMPTY:     "EMPTY"     >
    |
	< KEYWORD_SELECTION: "SELECTION" >
    |
//	< KEYWORD_INSERT:    "INSERT"    >
//  |
	< KEYWORD_NOTHING:   "NOTHING"   >
    |
	< KEYWORD_DEFAULT:   "DEFAULT"   >
	|

/*
 * SAMPLING CLAUSE
 */
	< KEYWORD_SAMPLING:  "SAMPLING" >
    |
//	< KEYWORD_ON:        "ON"       >
//  |
	< KEYWORD_EVENT:     "EVENT"    >
    |
//	< KEYWORD_IF:        "IF"       >
//  |
//	< KEYWORD_EVERY:     "EVERY"    >
//  |
	< KEYWORD_ELSE:      "ELSE"     >
	|

/*
 *	Token della clausola *ON UNSUPPORTED SAMPLING RATE*
 */
//	< KEYWORD_ON:          "ON"          >
//  |
	< KEYWORD_UNSUPPORTED: "UNSUPPORTED" >
    |
	< KEYWORD_SAMPLE:      "SAMPLE"      >
    |
	< KEYWORD_RATE:        "RATE"        >
    |
	< KEYWORD_DO:          "DO"          >
    |
//	< KEYWORD_NOT:         "NOT"         >
//  |
	< KEYWORD_SLOW:        "SLOW"        >
    |
	< KEYWORD_DOWN:        "DOWN"        >
	|

/*
 * REFRESH CLAUSE
 */
	< KEYWORD_REFRESH:   "REFRESH" >
    |
//	< KEYWORD_EVERY:     "EVERY"   >
//  |
	< KEYWORD_NEVER:     "NEVER"   >
	|

/*
 * EXECUTE IF CLAUSE
 */
	< KEYWORD_EXECUTE:   "EXECUTE" >
    |
	< KEYWORD_IF:        "IF"      >
    |
	< KEYWORD_EXISTS :   "EXISTS" >
	|

/*
 * TERMINATE AFTER CLAUSE
 */
	< KEYWORD_TERMINATE:  "TERMINATE"  >
    |
	< KEYWORD_AFTER:      "AFTER"      >
    |
	< KEYWORD_SELECTIONS: "SELECTIONS" >
	|

/*
 * FROM CLAUSE
 */
	< KEYWORD_FROM:      "FROM" >
    |
//	< KEYWORD_AS:        "AS"   >
//  |

/*
 * SET CLAUSE
 */
  	< KEYWORD_SET:    "SET"  >
    |
//  < KEYWORD_ON: "ON"    >
//  |

/*
 * STREAM DATA STRUCTURE
 */
	< KEYWORD_STREAM:   "STREAM"   >
	|

/*
 * MISC TOKENS
 */
	< KEYWORD_SAMPLES:  "SAMPLES"  >
    |
	< KEYWORD_ONE:      "ONE"      >
    |
	< KEYWORD_IS:       "IS" >
    |
	< KEYWORD_BETWEEN:  "BETWEEN"  >
    |
	< KEYWORD_LIKE:     "LIKE"     >
	|

/*
 * ALGEBRAIC OPERATORS
 */
	< OPERATOR_MULTIPLY: "*" >
    |
	< OPERATOR_DIVIDE:   "/" >
    |
	< OPERATOR_PLUS:     "+" >
    |
	< OPERATOR_MINUS:    "-" >
	|

/*
 * BOOLEAN OPERATORS
 */

	< OPERATOR_NOT:     "NOT" >
    |
	< OPERATOR_XOR:     "XOR" >
    |
	< OPERATOR_AND:     "AND" >
    |
    < OPERATOR_OR:      "OR"  >
    |

/*
 * BITWISE OPERATORS
 */
	< OPERATOR_BITWISE_NOT: "!" >
    |
	< OPERATOR_BITWISE_LSH: "<<" >
    |
	< OPERATOR_BITWISE_RSH: ">>" >
    |
    < OPERATOR_BITWISE_XOR: "^" >
    |
	< OPERATOR_BITWISE_AND: "&" >
    |
	< OPERATOR_BITWISE_OR:  "|"  >
	|

/*
 * COMPARISON OPERATORS
 */
	< OPERATOR_GREATER:       ">"  >
    |
	< OPERATOR_LESS:          "<"  >
    |
	< OPERATOR_GREATER_EQUAL: ">=" >
    |
	< OPERATOR_LESS_EQUAL:    "<=" >
    |
	< OPERATOR_EQUAL:         "="  >
    |
	< OPERATOR_NOT_EQUAL:     "<>" | "!=" >
	|

/*
 *	FUNZIONI DI AGGREGAZIONE
 */
	< FUNCTION_COUNT:     "COUNT"     >
    |
	< FUNCTION_AVG:       "AVG"       >
    |
	< FUNCTION_MAX:       "MAX"       >
    |
	< FUNCTION_MIN:       "MIN"       >
    |
	< FUNCTION_SUM:       "SUM"       >
    |
//	< FUNCTION_TIMESTAMP: "TIMESTAMP" >
//  |

/*
 * TIME UNITS
 */
	< TIMEUNIT_S:  "seconds"      | "s"  >
    |
	< TIMEUNIT_M:  "minutes"      | "m"  >
    |
	< TIMEUNIT_H:  "hours"        | "h"  >
    |
	< TIMEUNIT_MS: "milliseconds" | "ms" >
    |
	< TIMEUNIT_D:  "days"         | "d"  >
    |
	< TIMEUNIT_MT: "months"       | "mt" >
	|

/*
 * DATA TYPES
 */
	< TYPE_ID:      "ID"        >
    |
	< TYPE_TS:      "TIMESTAMP" >
    |
	< TYPE_BOOLEAN: "BOOLEAN"   >
    |
	< TYPE_INTEGER: "INTEGER"   >
    |
	< TYPE_FLOAT:   "FLOAT"     >
    |
	< TYPE_STRING:  "STRING"    >
}

/*
*	COSTANTI
*
*	NB: I token introdotti in questa sezione NON devono essere usati direttamente nella grammatica.
*	Bisogna invece usare le corrispondenti produzioni.
*/

/*
*	Inizializzatore di costante per tipi definiti dall'utente
*/

TOKEN :
{
	< NEW:		"NEW" >
}

/*
*	Costante NULL
*/

TOKEN :
{
	< CONSTANT_NULL:     "NULL" >
}

/*
*	Costanti BOOLEANE: servono sia per definire l'insieme di valori booleani ( TRUE e FALSE)
*	che quello della logica a tre valori (TRUE, FALSE e UNKNOWN)
*/

TOKEN :
{
	< CONSTANT_BOOLEAN_TRUE:    "TRUE"    >
|
	< CONSTANT_BOOLEAN_FALSE:   "FALSE"   >
|
	< CONSTANT_BOOLEAN_UNKNOWN: "UNKNOWN" >
}

/*
*	Costanti NUMERICHE: servono per definire i valori di tipo intero e float.
*
*   NB: Si noti che CONSTANT_FLOAT non corrisponde a tutti i valori numerici, ma
*	soltanto a quelli che contengono un punto decimale ('.').
*   Quindi, per esempio, '3.5' sar� interpretato come CONSTANT_FLOAT, ma '3' sar�
*	interpretato come CONSTANT_INTEGER.
*/

TOKEN :
{
	<CONSTANT_INTEGER:
		(
		( <DIGIT> )+
		|
		<HEXADECIMAL>
		)
	>
|
	<CONSTANT_FLOAT:
		(
			( <CONSTANT_INTEGER> )? "." <CONSTANT_INTEGER> ( "E" (<OPERATOR_PLUS> | <OPERATOR_MINUS>)? <CONSTANT_INTEGER> )?
		|
			 <CONSTANT_INTEGER> "E" (<OPERATOR_PLUS> | <OPERATOR_MINUS>)? <CONSTANT_INTEGER>
		)
	>
}

/*
*   Costanti STRINGA: servono per definire il tipo di dato stringa.
*
*	 - Una stringa pu� essere delimitata sia da apici singoli (SINGLE_QUOTED_STRING)
*      che da apici doppi (DOUBLE_QUOTED_STRING).
*	 - Una stringa che contiene al suo interno lo stesso apice usato per delimitarla,
*      � valida solo se questo � raddoppiato (es: 'l''apice')
*
*	Le stringhe sono state definite facendo uso degli stati lessicali, in modo tale
*   da permettere di rilevare facilmente l'errore di "stringa non chiusa".
*/

TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_START: "'"  > : NON_SINGLE_QUOTED_STRING
|
	< CONSTANT_DOUBLE_QUOTED_STRING_START: "\"" > : NON_DOUBLE_QUOTED_STRING
}

<NON_SINGLE_QUOTED_STRING> TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_VALUE: (~["'"] | "'" "'")* > : NON_SINGLE_QUOTED_STRING_END
}

<NON_DOUBLE_QUOTED_STRING> TOKEN :
{
	< CONSTANT_DOUBLE_QUOTED_STRING_VALUE: (~["\""] | "\"" "\"")* > : NON_DOUBLE_QUOTED_STRING_END
}

<NON_SINGLE_QUOTED_STRING_END> TOKEN :
{
	< CONSTANT_SINGLE_QUOTED_STRING_END:  "'" > : DEFAULT
}

<NON_DOUBLE_QUOTED_STRING_END> TOKEN :
{
	< CONSTANT_DOUBLE_QUOTED_STRING_END: "\"" > : DEFAULT
}

/*
*	IDENTIFICATORI
*/

TOKEN :
{
	< #DIGIT:      ["0" - "9"]               >
|
	< #LITERAL:    ["a" - "z", "A" - "Z"] >
|
	< #UNDERSCORE: "_"                       >
|
	< #HEXADECIMAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
	< IDENTIFIER: ( <LITERAL> | <UNDERSCORE>) ( <DIGIT> | <LITERAL> | <UNDERSCORE> )* >
}

/************************************************************************************************
*     PRODUZIONI GENERICHE (Segni, Costanti, Nomi di campi, Nomi di tabelle, ecc..)             *
*                                                                                               *
************************************************************************************************/

void StatementSequence() :
{}
{
	Statement()
	(
		";"
		Statement()
	)*
	<EOF>
}

/************************************************************************************************
*     PRODUZIONI GENERICHE (Segni, Costanti, Nomi di campi, Nomi di tabelle, ecc..)             *
*                                                                                               *
************************************************************************************************/

/* Ritorna un flag per indicare se c'� il segno negativo */
void Sign() :
{}
{
	<OPERATOR_PLUS>
	|
	<OPERATOR_MINUS>
}

void LogicValue() :
{}
{
	<CONSTANT_BOOLEAN_TRUE>
	|
	<CONSTANT_BOOLEAN_FALSE>
	|
	<CONSTANT_BOOLEAN_UNKNOWN>
}

void ConstantNull() :
{}
{
	<CONSTANT_NULL>
}

void ConstantBoolean() :
{}
{
	(
		<CONSTANT_BOOLEAN_TRUE>
		|
		<CONSTANT_BOOLEAN_FALSE>
	)
}

void ConstantFloat() :
{}
{
	(
		<CONSTANT_INTEGER>
		|
		<CONSTANT_FLOAT>
	)
}

void ConstantInteger() :
{}
{
	<CONSTANT_INTEGER>
}

void ConstantString() :
{}
{
	(
		(
		<CONSTANT_SINGLE_QUOTED_STRING_START>
		<CONSTANT_SINGLE_QUOTED_STRING_VALUE>
		<CONSTANT_SINGLE_QUOTED_STRING_END>
		)
		|
		(
		<CONSTANT_DOUBLE_QUOTED_STRING_START>
		<CONSTANT_DOUBLE_QUOTED_STRING_VALUE>
		<CONSTANT_DOUBLE_QUOTED_STRING_END>
		)
	)
}

void ConstantUserDefined() :
{}
{
	<NEW>
	"("
		<IDENTIFIER>
		","
		ConstantString()
	")"
}

void Constant() :
{}
{
	(
		ConstantNull()
		|
		ConstantBoolean()
		|
		ConstantString()
		|
		LOOKAHEAD(1)
		ConstantInteger()
		|
		ConstantFloat()
		|
		ConstantUserDefined()
	)
}

void SignedConstant() :
{}
{
	[
		Sign()
	]
	Constant()
}

void ComparisonOperator() :
{}
{
	<OPERATOR_GREATER>
	|
	<OPERATOR_LESS>
	|
	<OPERATOR_GREATER_EQUAL>
	|
	<OPERATOR_LESS_EQUAL>
	|
	<OPERATOR_EQUAL>
	|
	<OPERATOR_NOT_EQUAL>
}

void FieldType() :
{}
{
	(
	<TYPE_ID>
	|
	<TYPE_TS>
	|
	<TYPE_BOOLEAN>
	|
	<TYPE_INTEGER>
	|
	<TYPE_FLOAT>
	|
	<TYPE_STRING>
	|
	<IDENTIFIER>
	)
}

void TimeUnit() :
{}
{
	(
		<TIMEUNIT_S>
	|
		<TIMEUNIT_M>
	|
		<TIMEUNIT_H>
	|
		<TIMEUNIT_MS>
	|
		<TIMEUNIT_D>
	|
		<TIMEUNIT_MT>
	)
}

void AggregationOperator() :
{}
{
	<FUNCTION_AVG>
	|
	<FUNCTION_MIN>
	|
	<FUNCTION_MAX>
	|
	<FUNCTION_SUM>
}

void Duration() :
{}
{
	ConstantFloat()
	TimeUnit()
}

void SamplesNumber() :
{}
{
	(
		(
			ConstantInteger()
			<KEYWORD_SAMPLES>
		)
		|
		(
			<KEYWORD_ONE>
		)
	)
}

void SelectionsNumber() :
{}
{
	(
		ConstantInteger()
		<KEYWORD_SELECTIONS>
	)
}

void WindowSize() :
{}
{
	LOOKAHEAD(2)
	Duration()
	|
	SamplesNumber()
}

void Identifier() :
{}
{
	<IDENTIFIER>
}

void QualifiedIdentifier() :
{}
{
	<IDENTIFIER>
	"."
	<IDENTIFIER>
}

void OptionallyQualifiedIdentifier() :
{}
{
	<IDENTIFIER>
	[
		"."
		<IDENTIFIER>
	]
}

void Aggregate(ExpressionType parExpressionType) :
{ Node expression; Node filter = null; Object window = null; AggregationType type; }
{
	(
		(
			<FUNCTION_COUNT>
			"("
			"*"
			 { type = AggregationType.COUNT; expression = new NodeConstant(new ConstantString("*")); }
		)
		|
		(
			type = AggregationOperator()
			"("
			expression = Expression(parExpressionType)
		)
	)
	(
		LOOKAHEAD( { parExpressionType == ExpressionType.LOW_LEVEL_ALL } )
		(
			","
			window = WindowSize()
			[
				","
				filter = Expression(parExpressionType)
			]
		)
		|
		LOOKAHEAD( { parExpressionType == ExpressionType.HIGH_LEVEL_ALL } )
		(
			[
				","
				filter = Expression(parExpressionType)
			]
		)
	)
	")"
	{ return ExpressionsHandler.getNodeAggregation(type, expression, window, filter); }
}

void FunctionCall(ExpressionType parExpressionType) :
{}
{
	<IDENTIFIER>
	(
		LOOKAHEAD(2)
		(
			"("
			")"
		)
		|
		(
			"("
			Expression(parExpressionType)
			(
				","
				Expression(parExpressionType)
			)*
			")"
		)
	)
}

void ExistsAttribute() :
{}
{
	<KEYWORD_EXISTS>
	"("
	(
		Identifier() /* LogicalObjectField */
		|
		<KEYWORD_ALL>
	)
	")"
}

/************************************************************************************************
*     PRODUZIONI PER LE ESPRESSIONI                                                             *
*                                                                                               *
************************************************************************************************/

void Expression(ExpressionType parExpressionType) :
{}
{
	ExpressionBooleanTerm(parExpressionType)
	(
		<OPERATOR_OR>
		ExpressionBooleanTerm(parExpressionType)
	)*
}

void ExpressionBooleanTerm(ExpressionType parExpressionType) :
{}
{
	ExpressionBooleanFactor(parExpressionType)
	(
		<OPERATOR_AND>
		ExpressionBooleanFactor(parExpressionType)
	)*
}

void ExpressionBooleanFactor(ExpressionType parExpressionType) :
{}
{
	ExpressionBooleanTest(parExpressionType)
	(
		<OPERATOR_XOR>
		ExpressionBooleanTest(parExpressionType)

	)*
}

void ExpressionBooleanTest(ExpressionType parExpressionType) :
{}
{
	(
		<OPERATOR_NOT>
	)*
	ExpressionBooleanPrimary(parExpressionType)
}

void LogicTest(Node firstNode) :
{}
{
	<KEYWORD_IS>
	[
		<OPERATOR_NOT>
	]
	LogicValue()
}

void ExpressionBooleanPrimary(ExpressionType parExpressionType) :
{}
{
	ExpressionBit(parExpressionType)
	[
		(
			ComparisonOperator()
			ExpressionBit(parExpressionType)

			[
				LogicTest(parentNode)
			]
		)
		|
		(
			<KEYWORD_IS>
			[
				<OPERATOR_NOT>
			]
			(
				(
					<CONSTANT_NULL>
					[
						LogicTest(parentNode)
					]
				)
				|
				(
					LogicValue()
				)

			)
		)
		|
		(
			<KEYWORD_BETWEEN>
			ExpressionBit(parExpressionType)
			<OPERATOR_AND>
			ExpressionBit(parExpressionType)

			[
				LogicTest(parentNode)
			]
		)
		|
		(
			<KEYWORD_LIKE>
			ConstantString()

			[
				LogicTest(parentNode)
			]
		)
	]
}

void ExpressionBit(ExpressionType parExpressionType) :
{}
{
	ExpressionBitTerm(parExpressionType)
	(
		<OPERATOR_BITWISE_OR>
		ExpressionBitTerm(parExpressionType)
	)*
}

void ExpressionBitTerm(ExpressionType parExpressionType) :
{}
{
	ExpressionBitFactor(parExpressionType)
	(
		<OPERATOR_BITWISE_AND>
		ExpressionBitFactor(parExpressionType)
	)*
}

void ExpressionBitFactor(ExpressionType parExpressionType) :
{}
{
	ExpressionBitShift(parExpressionType)
	(
		<OPERATOR_BITWISE_XOR>
		ExpressionBitShift(parExpressionType)
	)*
}

void ExpressionBitShift(ExpressionType parExpressionType) :
{}
{
	ExpressionBitTest(parExpressionType)
	[
		(
			<OPERATOR_BITWISE_LSH>
			|
			<OPERATOR_BITWISE_RSH>
		)
		ConstantInteger()
	]
}

void ExpressionBitTest(ExpressionType parExpressionType) :
{}
{
	(
		<OPERATOR_BITWISE_NOT>
	)*
	ExpressionValue(parExpressionType)
}

void ExpressionValue(ExpressionType parExpressionType) :
{}
{
	ExpressionValueTerm(parExpressionType)
	(
		(
			<OPERATOR_PLUS>
			|
			<OPERATOR_MINUS>
		)

		ExpressionValueTerm(parExpressionType)
	)*
}

void ExpressionValueTerm(ExpressionType parExpressionType) :
{}
{
	ExpressionValueFactor(parExpressionType)
	(
		(
			<OPERATOR_MULTIPLY>
			|
			<OPERATOR_DIVIDE>
		)

		ExpressionValueFactor(parExpressionType)
	)*
}

void ExpressionValueFactor(ExpressionType parExpressionType) :
{}
{
	[
		Sign()
	]
	ExpressionValuePrimary(parExpressionType)
}

void ExpressionValuePrimary(ExpressionType parExpressionType) :
{}
{
	Constant()
	|
	ExistsAttribute()
	|
	LOOKAHEAD(2)
	FunctionCall(parExpressionType)
	|
	(
		"("
		Expression(parExpressionType)
		")"
	)
	|
	LOOKAHEAD( { parExpressionType == ExpressionType.LOW_LEVEL_ALL } )
	(
		<TYPE_ID>
		|
		<KEYWORD_GROUPTS>
		|
		Aggregate(parExpressionType)
		|
		OptionallyQualifiedIdentifier() /* PilotJoinField, LogicalObjectField */
	)
	|
	LOOKAHEAD( { parExpressionType == ExpressionType.HIGH_LEVEL_ALL } )
	(
		Aggregate(parExpressionType)
		|
		OptionallyQualifiedIdentifier() /* WindowField */
	)
	|
	LOOKAHEAD( { parExpressionType == ExpressionType.LOW_LEVEL_NO_AGGR } )
	(
		<TYPE_ID>
		|
		OptionallyQualifiedIdentifier() /* PilotJoinField, LogicalObjectField */
	)
	|
	LOOKAHEAD( { parExpressionType == ExpressionType. LOW_LEVEL_NO_AGGR_NO_PILOT } )
	(
		(
		<TYPE_ID>
		|
		Identifier() /* LogicalObjectField */
		)
	)
}

/************************************************************************************************
*     PRODUZIONI RELATIVE A LISTE DI ELEMENTI                                                   *
*                                                                                               *
************************************************************************************************/

void FieldDefinitionList() :
{}
{
	"("
	FieldDefinition()
	(
		","
		FieldDefinition()

	)*
	")"
}

void FieldDefinition() :
{}
{
	Identifier() /* DataStructureField */
	FieldType()
	[
		<KEYWORD_DEFAULT>
		SignedConstant()
	]
}

void FieldList() :
{}
{
	"("
	Identifier() /* DataStructureField */
	(
		","
		Identifier() /* DataStructureField */
	)*
	")"
}

void EventList() :
{}
{
	Identifier() /* LogicalObjectEvent */ { ClausesContext.addEvent(tokenId); }
	(
		","
		Identifier() /* LogicalObjectEvent */ { ClausesContext.addEvent(tokenId); }
	)*
}

void CorrelatedTableList() :
{}
{
	CorrelatedTable()
	(
		","
		CorrelatedTable()
	)*
}

void CorrelatedTable() :
{}
{
	Identifier() /* DataStructureName */
	<KEYWORD_ON>
	Expression(ExpressionType.LOW_LEVEL_NO_AGGR)
}

void WindowDefinitionList() :
{}
{
	WindowDefinition()
	(
		","
		WindowDefinition()
	)*
}

void WindowDefinition() :
{}
{
	Identifier() /* DataStructureName */
	[
		"("
		WindowSize()
		")"
	]
	[
		<KEYWORD_AS>
		Identifier() /* DataStructureName */
	]
}

void FieldGroupingByList() :
{}
{
	(
		FieldGroupingBy()
		|
		FieldGroupingByTs()
	)
	(
		","
		FieldGroupingBy()
	)*
}

void FieldGroupingBy() :
{}
{
	Identifier() /* LogicalObjectField */
}

void FieldGroupingByTs() :
{}
{
	<TYPE_TS>
	"("
	Duration()
	","
	ConstantInteger()
	<KEYWORD_GROUPS>
	")"
}

void WindowFieldList() :
{}
{
	OptionallyQualifiedIdentifier() /* WindowField */
	(
		","
		OptionallyQualifiedIdentifier() /* WindowField */
	)*
}

/************************************************************************************************
*     PRODUZIONI RELATIVE AGLI STATEMENT                                                        *
*                                                                                               *
************************************************************************************************/

void Statement():
{}
{
  SetParametersStament()
  |
  CreationStatement()
  |
  InsertionStatement()
}

void SetParametersStament():
{}
{
  <KEYWORD_SET>
  	SetParameterList()
  	(
  		","
  		SetParameterList()
  	)*
  <KEYWORD_ON>
	(
		<IDENTIFIER>
		|
		ConstantInteger()
		|
		ConstantString()
	)
	(
		","
		(
			<IDENTIFIER>
			|
			ConstantInteger()
			|
			ConstantString()
		)
	)*
}

void SetParameterList():
{}
{
	Identifier()
	"="
	Constant()
}

void CreationStatement() :
{}
{
	<KEYWORD_CREATE>
	[
		<KEYWORD_OUTPUT>
	]
	(
		StreamCreationStatement()
	)
}

void StreamCreationStatement() :
{}
{
	CreateStreamClause()
	[
		<KEYWORD_AS>
		StreamSelectionStatement()
	]
}

void CreateStreamClause() :
{}
{
	<KEYWORD_STREAM>
	Identifier() /* DataStructureName */
	FieldDefinitionList()
}

void InsertionStatement() :
{}
{
	<KEYWORD_INSERT>
	<KEYWORD_INTO>
	StreamInsertionStatement()
}

void StreamInsertionStatement() :
{}
{
	InsertStreamClause()
	StreamSelectionStatement()
}

void InsertStreamClause() :
{}
{
	<KEYWORD_STREAM>
	Identifier() /* DataStructureName */
	[
		FieldList()
	]
}

void StreamSelectionStatement() :
{}
{
    LowEveryClause()
    LowSelectionStatement(ExpressionType.LOW_LEVEL_ALL)
}

void LowEveryClause() :
{}
{
	<KEYWORD_EVERY>
	(
		LOOKAHEAD(2)
		(
			Duration()
			[
				<KEYWORD_SYNCHRONIZED>
			]
		)
		|
		(
			SamplesNumber()
		)
	)
}

void LowSelectionStatement(ExpressionType parExpressionType) :
{}
{
	SelectClause(parExpressionType)
	[
		GroupByClause()
	]
	[
		HavingClause(parExpressionType)
	]
	[
		UpToClause()
	]
	[
		OnEmptySelectionClause()
	]
	SamplingClause()
	[
		ExecuteIfClause()
	]
	[
		TerminateAfterClause()
	]
}

void SelectClause(ExpressionType parExpressionType) :
{}
{
	<KEYWORD_SELECT>
	[
		<KEYWORD_DISTINCT>
		|
		<KEYWORD_ALL>
	]
	FieldSelectionList(parExpressionType)
}

void FieldSelectionList(ExpressionType parExpressionType) :
{}
{
	FieldSelection(parExpressionType)
	(
		","
		FieldSelection(parExpressionType)
	)*
}

void FieldSelection(ExpressionType parExpressionType) :
{}
{
	Expression(parExpressionType)
	[
		<KEYWORD_DEFAULT>
		SignedConstant()
	]
}

void WhereClause(ExpressionType parExpressionType) :
{}
{
	<KEYWORD_WHERE>
	Expression(parExpressionType)
}

void GroupByClause() :
{}
{
	<KEYWORD_GROUP>
	<KEYWORD_BY>
	FieldGroupingByList()
}

void GroupClause() :
{}
{
	<KEYWORD_GROUP>
	(
		(
			<KEYWORD_BY>
			WindowFieldList()
		)
		|
		(
			<KEYWORD_ALL>
		)
	)
}

void HavingClause(ExpressionType parExpressionType) :
{}
{
	<KEYWORD_HAVING>
	Expression(parExpressionType)
}

void UpToClause() :
{}
{
	<KEYWORD_UP>
	<KEYWORD_TO>
	WindowSize()
}

void OnEmptySelectionClause() :
{}
{
	<KEYWORD_ON>
	<KEYWORD_EMPTY>
	<KEYWORD_SELECTION>
	<KEYWORD_INSERT>
	(
		<KEYWORD_NOTHING>
		|
	 	<KEYWORD_DEFAULT>
	)
}

SamplingClause SamplingClause() :
{}
{
	<KEYWORD_SAMPLING>
	(
		OnEventClause()
		|
		(
			SamplingIfEveryClause()
			[
				OnUnsupportedSRClause()
			]
			[
				RefreshClause()
			]
		)
	)
	[
		WhereClause(ExpressionType.LOW_LEVEL_NO_AGGR)
	]
}

void OnEventClause() :
{}
{
	<KEYWORD_ON>
	<KEYWORD_EVENT>
	EventList()
}

void SamplingIfEveryClause() :
{}
{
	(
		(
			SamplingIfClause()
			SamplingEveryClause()
		)+
		(
			<KEYWORD_ELSE>
			SamplingEveryClause()
		)
	)
	|
	(
		SamplingEveryClause()
	)
}

void SamplingIfClause() :
{}
{
	<KEYWORD_IF>
	Expression(ExpressionType.LOW_LEVEL_NO_AGGR)
}

void SamplingEveryClause() :
{}
{
	<KEYWORD_EVERY>
	Expression(ExpressionType.LOW_LEVEL_NO_AGGR)
	TimeUnit()
}

OnUnsupportedSampleRateOptions OnUnsupportedSRClause() :
{}
{
	<KEYWORD_ON>
	<KEYWORD_UNSUPPORTED>
	<KEYWORD_SAMPLE>
	<KEYWORD_RATE>
	(
	(
		<KEYWORD_DO>
		<OPERATOR_NOT>
		<KEYWORD_SAMPLE>
	)
	|
	(
		<KEYWORD_SLOW>
		<KEYWORD_DOWN>
	)
	)
}

RefreshClause RefreshClause() :
{}
{
	<KEYWORD_REFRESH>
	(
		(
			OnEventClause()
		)
		|
		(
			<KEYWORD_EVERY>
			Duration()
		)
		|
		(
			<KEYWORD_NEVER>
		)
	)
}

void ExecuteIfClause() :
{}
{
	<KEYWORD_EXECUTE>
	<KEYWORD_IF>
	Expression(ExpressionType.LOW_LEVEL_NO_AGGR_NO_PILOT)
	[
		RefreshClause()
	]
}

TerminateAfterClause TerminateAfterClause() :
{}
{
	<KEYWORD_TERMINATE>
	<KEYWORD_AFTER>
	(
		LOOKAHEAD(2)
		Duration()
		|
		SelectionsNumber()
	)
}

void FromClause() :
{}
{
	<KEYWORD_FROM>
	WindowDefinitionList()
}
